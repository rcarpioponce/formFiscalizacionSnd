<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>SUNEDU - Formulario de Fiscalización</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="shortcut icon" href="./img/sunedu-favicon.png" />

  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-7s5uDGW3AHqw6xtJmNNtr+OBRJUlgkNJEo78P4b0yRw= sha512-nNo+yCHEyn0smMxSswnf/OnX6/KwJuZTlNZBjauKhTK0c+zT+q5JOCx0UFhXQ6rJR9jg6Es8gPuD2uZcYDLqSw==" crossorigin="anonymous">
  <style></style>


</head>
<body>
    <div class="container-fluid formFiscalizacion">
      <h1><figure><img src="./img/sunedu-favicon.png" height="32" width="32" alt="SUNEDU"></figure>SUNEDU - FORMULARIO DE FISCALIZACIÓN</h1>
      <form id="persona_natural" action="http://localhost/suneduFiscalizacion/public/denuncias" method="POST" target="_blank">
        <h2>DATOS DEL DENUNCIANTE (PERSONA NATURAL)</h2>
        <div class="form-group">
          <div class="row">
            <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
              <label>DOCUMENTO DE IDENTIDAD</label>
              <input type="text" class="form-control dni" name="dni" required placeholder="DNI">  
            </div>
            <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
              <label>NOMBRES Y APELLIDOS DEL DENUNCIANTE</label>
              <input type="text" class="form-control" name="nombre_completo" required placeholder="Nombre Completo">  
            </div>
          </div>
        </div>
        <div class="form-group">
          <div class="row">
            <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
              <label>EMAIL</label>
              <input type="email" class="form-control email" name="email" required placeholder="Email">    
            </div>
            <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
              <label>TELÉFONO</label>
              <input type="text" class="form-control telefono" name="telefono" required placeholder="Teléfono">    
            </div>
          </div>        
        </div>
        <div class="form-group">
          <label>DOMICILIO EN EL QUE DESEA RECIBIR LAS COMUNICACIONES</label>
          <input type="text" class="form-control domicilio_notificaciones" name="domicilio_notificaciones" required placeholder="Domicilio">    
        </div>

        <h2>DATOS DEL APODERADO/REPRESENTANTE</h2>
        <div class="form-group">
          <div class="row">
            <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
              <label>DOCUMENTO DE IDENTIDAD</label>
              <input type="text" class="form-control dni" name="dni_apoderado" placeholder="DNI" >  
            </div>
            <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
              <label>NOMBRES Y APELLIDOS DEL DENUNCIANTE</label>
              <input type="text" class="form-control" name="nombre_completo_apoderado" placeholder="Nombre del apoderado" >  
            </div>
          </div>
        </div>
        <div class="form-group">
          <div class="row">
            <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
              <label>EMAIL</label>
              <input type="email" class="form-control email" name="email_apoderado" placeholder="Email del Apoderado">    
            </div>
            <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
              <label>TELÉFONO</label>
              <input type="text" class="form-control telefono" name="telefono_apoderado" placeholder="Teléfono del Apoderado">    
            </div>
          </div>        
        </div>
        <div class="form-group">
          <label>DOMICILIO</label>
          <input type="text" class="form-control domicilio_apoderado" name="domicilio_apoderado" placeholder="Domicilio del Apoderado">    
        </div>

        <h2>DATOS DE LA INSTITUCIÓN DENUNCIADA</h2>
        <div class="form-group">
          <label>NOMBRE DE LA INSTITUCIÓN</label><!-- 
          <input type="text" class="form-control" name="nombre_institucion" required placeholder="Nombre completo de la institución"> -->
          <select class="form-control nombre_institucion" name="nombre_institucion" required></select>    
        </div>
        <div class="form-group">
          <label>REPRESENTANTE</label>
          <input type="text" class="form-control" name="representante_institucion" required placeholder="Nombre completo del representante de la institución">    
        </div>
        <div class="form-group">
          <label>DOMICILIO</label>
          <input type="text" class="form-control" name="domicilio_institucion" required placeholder="Domicilio de la institución">    
        </div>
        <div class="form-group">
          <label>¿LA DENUNCIA HA SIDO PRESENTADA ANTE OTRA INSTANCIA?</label>
          <p>Si la denuncia fue presentada en otra instancia seleccione <strong>SI</strong> en el siguiente control y luego en la sección de abajo especifique a que entidad(es) fue presentada e ingrese el número de expediente correspondiente.</p>
          <select class="form-control otra_instancia" name="otra_instancia">
            <option value="Si">SI</option>
            <option value="No" selected="true">NO</option>
          </select>              
        </div>
        <div class="form-group checkboxesOtraInstancia">
            <label>HA QUE INSTANCIA(S) HA SIDO PRESENTADA</label>
            <div class="row">
              <div class="col-lg-6 form-group col-sm-6 col-md-6 col-sm-6">
                <div class="checkbox">
                  <label>
                    <input type="checkbox" disabled="disabled" value="1" class="exp_congreso" id="exp_congreso" name="exp_congreso">
                    Congreso de la república
                  </label>               
                </div>                
              </div>
              <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group col-sm-6 col-md-6 col-sm-6">
                <input type="text" class="form-control exp_congreso" name="nro_expediente_congreso" disabled="disabled" placeholder="ingrese número de Expediente">
              </div>
            </div>


            <div class="row">
              <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
                <div class="checkbox">
                  <label>
                    <input type="checkbox" disabled="disabled" value="2" id="exp_minedu" class="exp_minedu" name="exp_minedu">
                    Ministerio de Educación
                  </label>               
                </div>                
              </div>
              <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
                <input type="text" class="form-control exp_minedu" name="nro_expediente_minedu" disabled="disabled" placeholder="ingrese número de Expediente">
              </div>
            </div>


            <div class="row">
              <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
                <div class="checkbox">
                  <label>
                    <input type="checkbox" disabled="disabled" value="3" class="exp_pj" id="exp_pj"  name="exp_pj">
                    Ministerio de Público / Poder Judicial
                  </label>               
                </div>                
              </div>
              <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
                <input type="text" class="form-control exp_pj" name="nro_expediente_pj" disabled="disabled" placeholder="ingrese número de Expediente">         
              </div>
            </div>

            <div class="row">
              <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
                <div class="checkbox">
                  <label>
                    <input type="checkbox" disabled="disabled" value="4" class="exp_contraloria" id="exp_contraloria" name="exp_contraloria">
                    Contraloría General de la república
                  </label>               
                </div>                
              </div>
              <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
                <input type="text" class="form-control exp_contraloria" name="nro_expediente_contraloria" disabled="disabled" placeholder="ingrese número de Expediente">
              </div>
            </div> 


            <div class="row">
              <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
                <div class="checkbox">
                  <label>
                    <input type="checkbox" disabled="disabled" value="5" class="exp_indecopi" id="exp_indecopi" name="exp_indecopi">
                    Indecopi
                  </label>               
                </div>                
              </div>
              <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6 form-group">
                <input type="text" class="form-control exp_indecopi" name="nro_expediente_indecopi" disabled="disabled" placeholder="ingrese número de Expediente">               
              </div>
            </div>


            <div class="row">
              <div class="col-xs-12 col-md-4 col-lg-4">
                <div class="checkbox">
                  <label>
                    <input type="checkbox" disabled="disabled" value="6" class="exp_otro" id="exp_otro"  name="exp_otro">
                    Otro (Especificar)
                  </label>               
                </div>                
              </div>
              <div class="form-group col-xs-12 col-md-4 col-lg-4">
                <input type="text" class="form-control exp_otro" name="nombre_campo_otro" disabled="disabled" placeholder="ingrese el nombre">                 
              </div>
              <div class="form-group col-xs-12 col-md-4 col-lg-4">
                <input type="text" class="form-control exp_otro" name="nro_expediente_otro" disabled="disabled" placeholder="ingrese número de Expediente">
              </div>
            </div>

          </div>

          <h2>DETALLES DE LA PRESUNTA INFRACCIÓN</h2>
          <div class="form-group">          
            <strong>INFRACCIÓN SOBRE:</strong>
            <p>
              <ul>
                <li>a. Disposiciones establecidas en la Nº 30220 - Ley Universitaria o lineamientos, directivas, guías y/o normas de otro rango que establezca la SUNEDU y que sean tipificadas como infracciones en el Reglamento de infracciones y sanciones.</li>
                <li>b. Condiciones básicas de calidad para ofrecer el servicio educativo superior universitario</li>
                <li>c. Condiciones básicas de calidad para ofrecer el servicio educativo conducente a otorgar grados y títulos equivalentes a los otorgados por las universidades</li>
                <li>d. Uso educativo de los recursos público y/o beneficios otorgados por el marco legal a las universidades</li>
              </ul>
            </p>
          </div>

          <div class="form-group">
            <label>DESCRIPCIÓN DE LOS HECHOS</label>
            <textarea class="form-control" placeholder="Ingrese la descripción de los hechos" required name="descripcion_hechos"></textarea>
          </div>

          <div class="form-group">
            <label>POTENCIALES AFECTADOS CON LOS HECHOS</label>
            <textarea class="form-control" placeholder="Ingrese a los potenciales afectados con los hechos" required name="afectados_hechos"></textarea>
          </div>

          <div class="form-group">
            <label>DOCUMENTOS SUSTENTATORIOS</label>
            <textarea class="form-control" placeholder="Ingrese los documentos sustentatorios" required name="docs_sustentatorios"></textarea>
          </div>
          <div class="form-group">
            <p>Constituyen documentos sustentatorios, entre otros, los impresos o fotocopiasde facsímil o fax, correos electrónicos ,escritos, cartas notariales, oficios, memorárdums, informes, resoluciones, planos, cuadros, fotografías, reproducciones de audio y video, y en general cualquier medio que recoja, contenga o represente algún hecho, actividad humana o su resultado.</p>            
          </div>

          <div class="form-group">
            <input type="submit" value="Enviar" class="form-control btn btn-success">
          </div>

        </div>


      </form>






      <form class="hidden">
        <div class="form-group">
          <label>DENOMINACIÓN O RAZÓN SOCIAL</label>
          <input type="text" class="form-control" name="razon_social" required>    
        </div>
        <div class="form-group">
          <label>PARTIDA ELECTRÓNICA DONDE SE ENCUENTRA INSCRITA EN SUNARP</label>
          <input type="text" class="form-control" name="partida_eletronica" required>    
        </div>
        <div class="form-group">
          <label>NOMBRES Y APELLIDOS DEL APODERADO/REPRESENTANTE</label>
          <input type="text" class="form-control" name="razon_social" required>    
        </div>
        <div class="form-group">
          <label>DOCUMENTO DE IDENTIDAD</label>
          <input type="text" class="form-control" name="dni" required>    
        </div>
        <div class="form-group">
          <label>DOMICILIO</label>
          <input type="text" class="form-control" name="domicilio" required>    
        </div>
        <div class="form-group">
          <label>EMAIL</label>
          <input type="email" class="form-control" name="email" required>    
        </div>
        <div class="form-group">
          <label>TELEFONO</label>
          <input type="text" class="form-control" name="telefono" required>    
        </div>                        
      </form>      
    </div>

  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha256-KXn5puMvxCw+dAYznun+drMdG1IFl3agK0p/pqT9KAo= sha512-2e8qq0ETcfWRI4HJBzQiA3UoyFk6tbNyG+qSaIBZLyW9Xf3sWZHN/lxe9fTh1U45DpPf07yj94KsUHHWe4Yk1A==" crossorigin="anonymous"></script>
  <script>/*
 * Input Mask Core
 * http://github.com/RobinHerbots/jquery.inputmask
 * Copyright (c) 2010 -	Robin Herbots
 * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
 * Version: 0.0.0-dev
 */
(function(factory) {
		if (typeof define === "function" && define.amd) {
			define(["inputmask.dependencyLib"], factory);
		} else if (typeof exports === "object") {
			module.exports = factory(require("./inputmask.dependencyLib.jquery"));
		} else {
			factory(window.dependencyLib || jQuery);
		}
	}
	(function($) {
		function Inputmask(alias, options) {
			//allow instanciating without new
			if (!(this instanceof Inputmask)) {
				return new Inputmask(alias, options);
			}

			if ($.isPlainObject(alias)) {
				options = alias;
			} else {
				options = options || {};
				options.alias = alias;
			}

			this.el = undefined;
			//init options
			this.opts = $.extend(true, {}, this.defaults, options);
			this.noMasksCache = options && options.definitions !== undefined;
			this.userOptions = options || {}; //user passed options
			this.events = {};
			resolveAlias(this.opts.alias, options, this.opts);
		}

		Inputmask.prototype = {
			//options default
			defaults: {
				placeholder: "_",
				optionalmarker: {
					start: "[",
					end: "]"
				},
				quantifiermarker: {
					start: "{",
					end: "}"
				},
				groupmarker: {
					start: "(",
					end: ")"
				},
				alternatormarker: "|",
				escapeChar: "\\",
				mask: null, //needs tobe null instead of undefined as the extend method does not consider props with the undefined value
				oncomplete: $.noop, //executes when the mask is complete
				onincomplete: $.noop, //executes when the mask is incomplete and focus is lost
				oncleared: $.noop, //executes when the mask is cleared
				repeat: 0, //repetitions of the mask: * ~ forever, otherwise specify an integer
				greedy: true, //true: allocated buffer for the mask and repetitions - false: allocate only if needed
				autoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor
				removeMaskOnSubmit: false, //remove the mask before submitting the form.
				clearMaskOnLostFocus: true,
				insertMode: true, //insert the input or overwrite the input
				clearIncomplete: false, //clear the incomplete input on blur
				aliases: {}, //aliases definitions => see jquery.inputmask.extensions.js
				alias: null,
				onKeyDown: $.noop, //callback to implement autocomplete on certain keys for example. args => event, buffer, caretPos, opts
				onBeforeMask: null, //executes before masking the initial value to allow preprocessing of the initial value.	args => initialValue, opts => return processedValue
				onBeforePaste: function(pastedValue, opts) {
					return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(pastedValue, opts) : pastedValue;
				}, //executes before masking the pasted value to allow preprocessing of the pasted value.	args => pastedValue, opts => return processedValue
				onBeforeWrite: null, //executes before writing to the masked element. args => event, opts
				onUnMask: null, //executes after unmasking to allow postprocessing of the unmaskedvalue.	args => maskedValue, unmaskedValue, opts
				showMaskOnFocus: true, //show the mask-placeholder when the input has focus
				showMaskOnHover: true, //show the mask-placeholder when hovering the empty input
				onKeyValidation: $.noop, //executes on every key-press with the result of isValid. Params: key, result, opts
				skipOptionalPartCharacter: " ", //a character which can be used to skip an optional part of a mask
				showTooltip: false, //show the activemask as tooltip
				tooltip: undefined, //tooltip to show
				numericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)
				rightAlign: false, //align to the right
				undoOnEscape: true, //pressing escape reverts the value to the value before focus
				//numeric basic properties
				radixPoint: "", //".", // | ","
				groupSeparator: "", //",", // | "."
				radixFocus: false, //position caret to radixpoint on initial click
				//numeric basic properties
				nojumps: false, //do not jump over fixed parts in the mask
				nojumpsThreshold: 0, //start nojumps as of
				keepStatic: null, //try to keep the mask static while typing. Decisions to alter the mask will be posponed if possible - null see auto selection for multi masks
				positionCaretOnTab: false, //when enabled the caret position is set after the latest valid position on TAB
				tabThrough: false, //allows for tabbing through the different parts of the masked field
				supportsInputType: ["text", "tel", "password"], //list with the supported input types
				definitions: {
					"9": {
						validator: "[0-9]",
						cardinality: 1,
						definitionSymbol: "*"
					},
					"a": {
						validator: "[A-Za-z\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5]",
						cardinality: 1,
						definitionSymbol: "*"
					},
					"*": {
						validator: "[0-9A-Za-z\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5]",
						cardinality: 1
					}
				},
				//specify keyCodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF
				ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123],
				isComplete: null, //override for isComplete - args => buffer, opts - return true || false
				canClearPosition: $.noop, //hook to alter the clear behavior in the stripValidPositions args => maskset, position, lastValidPosition, opts => return true|false
				postValidation: null, //hook to postValidate the result from isValid.	Usefull for validating the entry as a whole.	args => buffer, opts => return true/false
				staticDefinitionSymbol: undefined, //specify a definitionSymbol for static content, used to make matches for alternators
				jitMasking: false, //just in time masking ~ only mask while typing
			},
			masksCache: {},
			mask: function(elems) {
				var that = this;
				if (typeof elems === "string") {
					elems = document.getElementById(elems) || document.querySelectorAll(elems);
				}
				elems = elems.nodeName ? [elems] : elems;
				$.each(elems, function(ndx, el) {
					var scopedOpts = $.extend(true, {}, that.opts);
					importAttributeOptions(el, scopedOpts, $.extend(true, {}, that.userOptions));
					var maskset = generateMaskSet(scopedOpts, that.noMasksCache);
					if (maskset !== undefined) {
						if (el.inputmask !== undefined) {
							el.inputmask.remove();
						}
						//store inputmask instance on the input with element reference
						el.inputmask = new Inputmask();
						el.inputmask.opts = scopedOpts;
						el.inputmask.noMasksCache = that.noMasksCache;
						el.inputmask.userOptions = $.extend(true, {}, that.userOptions);
						el.inputmask.el = el;
						el.inputmask.maskset = maskset;
						el.inputmask.isRTL = false;

						$.data(el, "_inputmask_opts", scopedOpts);

						maskScope({
							"action": "mask",
							"el": el
						});
					}
				});
				return elems && elems[0] ? (elems[0].inputmask || this) : this;
			},
			option: function(options) { //set extra options || retrieve value of a current option
				if (typeof options === "string") {
					return this.opts[options];
				} else if (typeof options === "object") {
					$.extend(this.opts, options);
					$.extend(this.userOptions, options); //user passed options
					//remask
					if (this.el) {
						if (options.mask !== undefined || options.alias !== undefined) {
							this.mask(this.el);
						} else {
							$.data(this.el, "_inputmask_opts", this.opts);
							maskScope({
								"action": "mask",
								"el": this.el
							});
						}
					}
					return this;
				}
			},
			unmaskedvalue: function(value) {
				return maskScope({
					"action": "unmaskedvalue",
					"el": this.el,
					"value": value
				}, this.el && this.el.inputmask ? this.el.inputmask.maskset : generateMaskSet(this.opts, this.noMasksCache), this.opts);
			},
			remove: function() {
				if (this.el) {
					maskScope({
						"action": "remove",
						"el": this.el
					});
					this.el.inputmask = undefined; //delete ~ undefined
					return this.el;
				}
			},
			getemptymask: function() { //return the default (empty) mask value, usefull for setting the default value in validation
				return maskScope({
					"action": "getemptymask"
				}, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
			},
			hasMaskedValue: function() { //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value
				return !this.opts.autoUnmask;
			},
			isComplete: function() {
				return maskScope({
					"action": "isComplete",
					"el": this.el //optional
				}, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
			},
			getmetadata: function() { //return mask metadata if exists
				return maskScope({
					"action": "getmetadata"
				}, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
			},
			isValid: function(value) {
				return maskScope({
					"action": "isValid",
					"value": value
				}, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
			},
			format: function(value, metadata) {
				return maskScope({
					"action": "format",
					"value": value,
					"metadata": metadata //true/false getmetadata
				}, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);
			}
		};

		//apply defaults, definitions, aliases
		Inputmask.extendDefaults = function(options) {
			$.extend(true, Inputmask.prototype.defaults, options);
		};
		Inputmask.extendDefinitions = function(definition) {
			$.extend(true, Inputmask.prototype.defaults.definitions, definition);
		};
		Inputmask.extendAliases = function(alias) {
			$.extend(true, Inputmask.prototype.defaults.aliases, alias);
		};
		//static fn on inputmask
		Inputmask.format = function(value, options, metadata) {
			return Inputmask(options).format(value, metadata);
		};
		Inputmask.unmask = function(value, options) {
			return Inputmask(options).unmaskedvalue(value);
		};
		Inputmask.isValid = function(value, options) {
			return Inputmask(options).isValid(value);
		};
		Inputmask.remove = function(elems) {
			$.each(elems, function(ndx, el) {
				if (el.inputmask) el.inputmask.remove();
			});
		};
		Inputmask.escapeRegex = function(str) {
			var specials = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"];
			return str.replace(new RegExp("(\\" + specials.join("|\\") + ")", "gim"), "\\$1");
		};
		Inputmask.keyCode = {
			ALT: 18,
			BACKSPACE: 8,
			CAPS_LOCK: 20,
			COMMA: 188,
			COMMAND: 91,
			COMMAND_LEFT: 91,
			COMMAND_RIGHT: 93,
			CONTROL: 17,
			DELETE: 46,
			DOWN: 40,
			END: 35,
			ENTER: 13,
			ESCAPE: 27,
			HOME: 36,
			INSERT: 45,
			LEFT: 37,
			MENU: 93,
			NUMPAD_ADD: 107,
			NUMPAD_DECIMAL: 110,
			NUMPAD_DIVIDE: 111,
			NUMPAD_ENTER: 108,
			NUMPAD_MULTIPLY: 106,
			NUMPAD_SUBTRACT: 109,
			PAGE_DOWN: 34,
			PAGE_UP: 33,
			PERIOD: 190,
			RIGHT: 39,
			SHIFT: 16,
			SPACE: 32,
			TAB: 9,
			UP: 38,
			WINDOWS: 91
		};

		//helper functions
		function isInputEventSupported(eventName) {
			var el = document.createElement("input"),
				evName = "on" + eventName,
				isSupported = (evName in el);
			if (!isSupported) {
				el.setAttribute(evName, "return;");
				isSupported = typeof el[evName] == "function";
			}
			el = null;
			return isSupported;
		}

		function isElementTypeSupported(input, opts) {
			var elementType = input.getAttribute("type");
			var isSupported = (input.tagName === "INPUT" && opts.supportsInputType.indexOf(elementType) !== -1) || input.isContentEditable || input.tagName === "TEXTAREA";
			if (!isSupported) {
				var el = document.createElement("input");
				el.setAttribute("type", elementType);
				isSupported = el.type === "text"; //apply mask only if the type is not natively supported
				el = null;
			}
			return isSupported;
		}

		function resolveAlias(aliasStr, options, opts) {
			var aliasDefinition = opts.aliases[aliasStr];
			if (aliasDefinition) {
				if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts); //alias is another alias
				$.extend(true, opts, aliasDefinition); //merge alias definition in the options
				$.extend(true, opts, options); //reapply extra given options
				return true;
			} else //alias not found - try as mask
			if (opts.mask === null) {
				opts.mask = aliasStr;
			}

			return false;
		}

		function importAttributeOptions(npt, opts, userOptions) {
			var attrOptions = npt.getAttribute("data-inputmask"),
				option, dataoptions, optionData, p;

			function importOption(option, optionData) {
				optionData = optionData !== undefined ? optionData : npt.getAttribute("data-inputmask-" + option);
				if (optionData !== null) {
					if (typeof optionData === "string") {
						if (option.indexOf("on") === 0) optionData = window[optionData]; //get function definition
						else if (optionData === "false") optionData = false;
						else if (optionData === "true") optionData = true;
					}
					userOptions[option] = optionData;
				}
			}

			if (attrOptions && attrOptions !== "") {
				attrOptions = attrOptions.replace(new RegExp("'", "g"), '"');
				dataoptions = JSON.parse("{" + attrOptions + "}");
			}

			//resolve aliases
			if (dataoptions) { //pickup alias from data-inputmask
				optionData = undefined;
				for (p in dataoptions) {
					if (p.toLowerCase() === "alias") {
						optionData = dataoptions[p];
						break;
					}
				}
			}
			importOption("alias", optionData); //pickup alias from data-inputmask-alias
			if (userOptions.alias) {
				resolveAlias(userOptions.alias, userOptions, opts);
			}

			for (option in opts) {
				if (dataoptions) {
					optionData = undefined;
					for (p in dataoptions) {
						if (p.toLowerCase() === option.toLowerCase()) {
							optionData = dataoptions[p];
							break;
						}
					}
				}
				importOption(option, optionData);
			}

			$.extend(true, opts, userOptions);
			return opts;
		}

		function generateMaskSet(opts, nocache) {
			var ms;

			function analyseMask(mask) {
				var tokenizer = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g,
					escaped = false,
					currentToken = new MaskToken(),
					match,
					m,
					openenings = [],
					maskTokens = [],
					openingToken,
					currentOpeningToken,
					alternator,
					lastMatch,
					groupToken;

				function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {
					this.matches = [];
					this.isGroup = isGroup || false;
					this.isOptional = isOptional || false;
					this.isQuantifier = isQuantifier || false;
					this.isAlternator = isAlternator || false;
					this.quantifier = {
						min: 1,
						max: 1
					};
				}
				//test definition => {fn: RegExp/function, cardinality: int, optionality: bool, newBlockMarker: bool, casing: null/upper/lower, def: definitionSymbol, placeholder: placeholder, mask: real maskDefinition}
				function insertTestDefinition(mtoken, element, position) {
					var maskdef = opts.definitions[element];
					position = position !== undefined ? position : mtoken.matches.length;
					var prevMatch = mtoken.matches[position - 1];
					if (maskdef && !escaped) {
						maskdef.placeholder = $.isFunction(maskdef.placeholder) ? maskdef.placeholder(opts) : maskdef.placeholder;
						var prevalidators = maskdef.prevalidator,
							prevalidatorsL = prevalidators ? prevalidators.length : 0;
						//handle prevalidators
						for (var i = 1; i < maskdef.cardinality; i++) {
							var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [],
								validator = prevalidator.validator,
								cardinality = prevalidator.cardinality;
							mtoken.matches.splice(position++, 0, {
								fn: validator ? typeof validator === "string" ? new RegExp(validator) : new function() {
									this.test = validator;
								} : new RegExp("."),
								cardinality: cardinality ? cardinality : 1,
								optionality: mtoken.isOptional,
								newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),
								casing: maskdef.casing,
								def: maskdef.definitionSymbol || element,
								placeholder: maskdef.placeholder,
								mask: element
							});
							prevMatch = mtoken.matches[position - 1];
						}
						mtoken.matches.splice(position++, 0, {
							fn: maskdef.validator ? typeof maskdef.validator == "string" ? new RegExp(maskdef.validator) : new function() {
								this.test = maskdef.validator;
							} : new RegExp("."),
							cardinality: maskdef.cardinality,
							optionality: mtoken.isOptional,
							newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),
							casing: maskdef.casing,
							def: maskdef.definitionSymbol || element,
							placeholder: maskdef.placeholder,
							mask: element
						});
					} else {
						mtoken.matches.splice(position++, 0, {
							fn: null,
							cardinality: 0,
							optionality: mtoken.isOptional,
							newBlockMarker: prevMatch === undefined || prevMatch.def !== element,
							casing: null,
							def: opts.staticDefinitionSymbol || element,
							placeholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,
							mask: element
						});
						escaped = false;
					}
				}

				function verifyGroupMarker(lastMatch, isOpenGroup) {
					if (lastMatch.isGroup) { //this is not a group but a normal mask => convert
						lastMatch.isGroup = false;
						insertTestDefinition(lastMatch, opts.groupmarker.start, 0);
						if (isOpenGroup !== true) {
							insertTestDefinition(lastMatch, opts.groupmarker.end);
						}
					}
				}

				function maskCurrentToken(m, currentToken, lastMatch, extraCondition) {
					if (currentToken.matches.length > 0 && (extraCondition === undefined || extraCondition)) {
						lastMatch = currentToken.matches[currentToken.matches.length - 1];
						verifyGroupMarker(lastMatch);
					}
					insertTestDefinition(currentToken, m);
				}

				function defaultCase() {
					if (openenings.length > 0) {
						currentOpeningToken = openenings[openenings.length - 1];
						maskCurrentToken(m, currentOpeningToken, lastMatch, !currentOpeningToken.isAlternator);
						if (currentOpeningToken.isAlternator) { //handle alternator a | b case
							alternator = openenings.pop();
							for (var mndx = 0; mndx < alternator.matches.length; mndx++) {
								alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group
							}
							if (openenings.length > 0) {
								currentOpeningToken = openenings[openenings.length - 1];
								currentOpeningToken.matches.push(alternator);
							} else {
								currentToken.matches.push(alternator);
							}
						}
					} else {
						maskCurrentToken(m, currentToken, lastMatch);
					}
				}

				function reverseTokens(maskToken) {
					function reverseStatic(st) {
						if (st === opts.optionalmarker.start) st = opts.optionalmarker.end;
						else if (st === opts.optionalmarker.end) st = opts.optionalmarker.start;
						else if (st === opts.groupmarker.start) st = opts.groupmarker.end;
						else if (st === opts.groupmarker.end) st = opts.groupmarker.start;

						return st;
					}

					maskToken.matches = maskToken.matches.reverse();
					for (var match in maskToken.matches) {
						var intMatch = parseInt(match);
						if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) { //reposition quantifier
							var qt = maskToken.matches[match];
							maskToken.matches.splice(match, 1);
							maskToken.matches.splice(intMatch + 1, 0, qt);
						}
						if (maskToken.matches[match].matches !== undefined) {
							maskToken.matches[match] = reverseTokens(maskToken.matches[match]);
						} else {
							maskToken.matches[match] = reverseStatic(maskToken.matches[match]);
						}
					}

					return maskToken;
				}

				while (match = tokenizer.exec(mask)) {
					m = match[0];

					if (escaped) {
						defaultCase();
						continue;
					}
					switch (m.charAt(0)) {
						case opts.escapeChar:
							escaped = true;
							break;
						case opts.optionalmarker.end:
							// optional closing
						case opts.groupmarker.end:
							// Group closing
							openingToken = openenings.pop();
							if (openingToken !== undefined) {
								if (openenings.length > 0) {
									currentOpeningToken = openenings[openenings.length - 1];
									currentOpeningToken.matches.push(openingToken);
									if (currentOpeningToken.isAlternator) { //handle alternator (a) | (b) case
										alternator = openenings.pop();
										for (var mndx = 0; mndx < alternator.matches.length; mndx++) {
											alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group
										}
										if (openenings.length > 0) {
											currentOpeningToken = openenings[openenings.length - 1];
											currentOpeningToken.matches.push(alternator);
										} else {
											currentToken.matches.push(alternator);
										}
									}
								} else {
									currentToken.matches.push(openingToken);
								}
							} else defaultCase();
							break;
						case opts.optionalmarker.start:
							// optional opening
							openenings.push(new MaskToken(false, true));
							break;
						case opts.groupmarker.start:
							// Group opening
							openenings.push(new MaskToken(true));
							break;
						case opts.quantifiermarker.start:
							//Quantifier
							var quantifier = new MaskToken(false, false, true);

							m = m.replace(/[{}]/g, "");
							var mq = m.split(","),
								mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
								mq1 = mq.length === 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1]));
							if (mq1 === "*" || mq1 === "+") {
								mq0 = mq1 === "*" ? 0 : 1;
							}
							quantifier.quantifier = {
								min: mq0,
								max: mq1
							};
							if (openenings.length > 0) {
								var matches = openenings[openenings.length - 1].matches;
								match = matches.pop();
								if (!match.isGroup) {
									groupToken = new MaskToken(true);
									groupToken.matches.push(match);
									match = groupToken;
								}
								matches.push(match);
								matches.push(quantifier);
							} else {
								match = currentToken.matches.pop();
								if (!match.isGroup) {
									groupToken = new MaskToken(true);
									groupToken.matches.push(match);
									match = groupToken;
								}
								currentToken.matches.push(match);
								currentToken.matches.push(quantifier);
							}
							break;
						case opts.alternatormarker:
							if (openenings.length > 0) {
								currentOpeningToken = openenings[openenings.length - 1];
								lastMatch = currentOpeningToken.matches.pop();
							} else {
								lastMatch = currentToken.matches.pop();
							}
							if (lastMatch.isAlternator) {
								openenings.push(lastMatch);
							} else {
								alternator = new MaskToken(false, false, false, true);
								alternator.matches.push(lastMatch);
								openenings.push(alternator);
							}
							break;
						default:
							defaultCase();
					}
				}

				while (openenings.length > 0) {
					openingToken = openenings.pop();
					verifyGroupMarker(openingToken, true);
					currentToken.matches.push(openingToken);
				}
				if (currentToken.matches.length > 0) {
					lastMatch = currentToken.matches[currentToken.matches.length - 1];
					verifyGroupMarker(lastMatch);
					maskTokens.push(currentToken);
				}

				if (opts.numericInput) {
					reverseTokens(maskTokens[0]);
				}
				// console.log(JSON.stringify(maskTokens));
				return maskTokens;
			}

			function generateMask(mask, metadata) {
				if (mask === null || mask === "") {
					return undefined;
				} else {
					if (mask.length === 1 && opts.greedy === false && opts.repeat !== 0) {
						opts.placeholder = "";
					} //hide placeholder with single non-greedy mask
					if (opts.repeat > 0 || opts.repeat === "*" || opts.repeat === "+") {
						var repeatStart = opts.repeat === "*" ? 0 : (opts.repeat === "+" ? 1 : opts.repeat);
						mask = opts.groupmarker.start + mask + opts.groupmarker.end + opts.quantifiermarker.start + repeatStart + "," + opts.repeat + opts.quantifiermarker.end;
					}

					// console.log(mask);
					var masksetDefinition;
					if (Inputmask.prototype.masksCache[mask] === undefined || nocache === true) {
						masksetDefinition = {
							"mask": mask,
							"maskToken": analyseMask(mask),
							"validPositions": {},
							"_buffer": undefined,
							"buffer": undefined,
							"tests": {},
							"metadata": metadata
						};
						if (nocache !== true) {
							Inputmask.prototype.masksCache[opts.numericInput ? mask.split("").reverse().join("") : mask] = masksetDefinition;
							masksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[opts.numericInput ? mask.split("").reverse().join("") : mask]);
						}
					} else masksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[opts.numericInput ? mask.split("").reverse().join("") : mask]);

					return masksetDefinition;
				}
			}

			function preProcessMask(mask) {
				mask = mask.toString();
				// if (opts.numericInput) {
				// 	mask = mask.split('').reverse();
				// 	mask = mask.join('');
				// }
				return mask;
			}

			if ($.isFunction(opts.mask)) { //allow mask to be a preprocessing fn - should return a valid mask
				opts.mask = opts.mask(opts);
			}
			if ($.isArray(opts.mask)) {
				if (opts.mask.length > 1) {
					opts.keepStatic = opts.keepStatic === null ? true : opts.keepStatic; //enable by default when passing multiple masks when the option is not explicitly specified
					var altMask = "(";
					$.each(opts.numericInput ? opts.mask.reverse() : opts.mask, function(ndx, msk) {
						if (altMask.length > 1) {
							altMask += ")|(";
						}
						if (msk.mask !== undefined && !$.isFunction(msk.mask)) {
							altMask += preProcessMask(msk.mask);
						} else {
							altMask += preProcessMask(msk);
						}
					});
					altMask += ")";
					return generateMask(altMask, opts.mask);
				} else opts.mask = opts.mask.pop();
			}

			if (opts.mask) {
				if (opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask)) {
					ms = generateMask(preProcessMask(opts.mask.mask), opts.mask);
				} else {
					ms = generateMask(preProcessMask(opts.mask), opts.mask);
				}
			}

			return ms;
		}

		var ua = navigator.userAgent,
			iphone = ua.match(new RegExp("iphone", "i")) !== null,
			android = ua.match(new RegExp("android.*safari.*", "i")) !== null,
			androidchrome = ua.match(new RegExp("android.*chrome.*", "i")) !== null,
			androidfirefox = ua.match(new RegExp("android.*firefox.*", "i")) !== null,
			kindle = /Kindle/i.test(ua) || /Silk/i.test(ua) || /KFTT/i.test(ua) || /KFOT/i.test(ua) || /KFJWA/i.test(ua) || /KFJWI/i.test(ua) || /KFSOWI/i.test(ua) || /KFTHWA/i.test(ua) || /KFTHWI/i.test(ua) || /KFAPWA/i.test(ua) || /KFAPWI/i.test(ua),
			PasteEventType = isInputEventSupported("paste") ? "paste" : isInputEventSupported("input") ? "input" : "propertychange";

		//if (androidchrome) {
		//		var browser = navigator.userAgent.match(new RegExp("chrome.*", "i")),
		//				version = parseInt(new RegExp(/[0-9]+/).exec(browser));
		//		androidchrome32 = (version == 32);
		//}

		//masking scope
		//actionObj definition see below
		function maskScope(actionObj, maskset, opts) {
			var isRTL = false,
				undoValue,
				compositionData,
				el, $el,
				skipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround
				skipInputEvent = false, //skip when triggered from within inputmask
				ignorable = false,
				maxLength,
				mouseEnter = true;

			//maskset helperfunctions
			function getMaskTemplate(baseOnInput, minimalPos, includeInput) {
				minimalPos = minimalPos || 0;
				var maskTemplate = [],
					ndxIntlzr, pos = 0,
					test, testPos, lvp = getLastValidPosition();
				do {
					if (baseOnInput === true && getMaskSet().validPositions[pos]) {
						var validPos = getMaskSet().validPositions[pos];
						test = validPos.match;
						ndxIntlzr = validPos.locator.slice();
						maskTemplate.push(includeInput === true ? validPos.input : getPlaceholder(pos, test));
					} else {
						//console.log("getmasktemplate " + pos + " " + JSON.stringify(ndxIntlzr));
						testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
						test = testPos.match;
						ndxIntlzr = testPos.locator.slice();
						if (opts.jitMasking !== true || pos < lvp) {
							maskTemplate.push(getPlaceholder(pos, test));
						}
					}
					pos++;
				} while ((maxLength === undefined || pos - 1 < maxLength) && test.fn !== null || (test.fn === null && test.def !== "") || minimalPos >= pos);
				if (maskTemplate[maskTemplate.length - 1] === "") {
					maskTemplate.pop(); //drop the last one which is empty
				}
				return maskTemplate;
			}

			function getMaskSet() {
				return maskset;
			}

			function resetMaskSet(soft) {
				var maskset = getMaskSet();
				maskset.buffer = undefined;
				if (soft !== true) {
					maskset.tests = {};
					maskset._buffer = undefined;
					maskset.validPositions = {};
					maskset.p = 0;
				}
			}

			function getLastValidPosition(closestTo, strict) {
				var maskset = getMaskSet(),
					lastValidPosition = -1,
					valids = maskset.validPositions;
				if (closestTo === undefined) closestTo = -1;
				var before = lastValidPosition,
					after = lastValidPosition;
				for (var posNdx in valids) {
					var psNdx = parseInt(posNdx);
					if (valids[psNdx] && (strict || valids[psNdx].match.fn !== null)) {
						if (psNdx <= closestTo) before = psNdx;
						if (psNdx >= closestTo) after = psNdx;
					}
				}
				lastValidPosition = (before !== -1 && (closestTo - before) > 1) || after < closestTo ? before : after;
				return lastValidPosition;
			}

			function setValidPosition(pos, validTest, fromSetValid) {
				if (opts.insertMode && getMaskSet().validPositions[pos] !== undefined && fromSetValid === undefined) {
					//reposition & revalidate others
					var positionsClone = $.extend(true, {}, getMaskSet().validPositions),
						lvp = getLastValidPosition(),
						i;
					for (i = pos; i <= lvp; i++) { //clear selection
						delete getMaskSet().validPositions[i];
					}
					getMaskSet().validPositions[pos] = validTest;
					var valid = true,
						j, vps = getMaskSet().validPositions;
					for (i = (j = pos); i <= lvp; i++) {
						var t = positionsClone[i];
						if (t !== undefined) {
							var posMatch = j,
								prevPosMatch = -1;
							while (posMatch < getMaskLength() && ((t.match.fn == null && vps[i] && (vps[i].match.optionalQuantifier === true || vps[i].match.optionality === true)) || t.match.fn != null)) {
								//determine next position
								if (t.match.fn === null || (!opts.keepStatic && vps[i] && (vps[i + 1] !== undefined && getTests(i + 1, vps[i].locator.slice(), i).length > 1 || vps[i].alternation !== undefined))) {
									posMatch++;
								} else posMatch = seekNext(j);

								//does it match
								if (positionCanMatchDefinition(posMatch, t.match.def)) {
									valid = isValid(posMatch, t.input, true, true) !== false;
									j = posMatch;
									break;
								} else {
									valid = t.match.fn == null;
									if (prevPosMatch === posMatch) break; //prevent endless loop
									prevPosMatch = posMatch;
								}
							}
						}
						if (!valid) break;
					}

					if (!valid) {
						getMaskSet().validPositions = $.extend(true, {}, positionsClone);
						resetMaskSet(true);
						return false;
					}
				} else getMaskSet().validPositions[pos] = validTest;

				resetMaskSet(true);
				return true;
			}

			function stripValidPositions(start, end, nocheck, strict) {
				var i, startPos = start;
				getMaskSet().p = start; //needed for alternated position after overtype selection

				for (i = startPos; i < end; i++) { //clear selection
					if (getMaskSet().validPositions[i] !== undefined) {
						if (nocheck === true || opts.canClearPosition(getMaskSet(), i, getLastValidPosition(), strict, opts) !== false) {
							delete getMaskSet().validPositions[i];
						}
					}
				}

				/*eslint-disable semi-spacing */
				for (i = startPos + 1; i <= getLastValidPosition();) {
					/*eslint-disable semi-spacing */
					while (getMaskSet().validPositions[startPos] !== undefined) startPos++;
					var s = getMaskSet().validPositions[startPos];
					if (i < startPos) i = startPos + 1;
					// while (getMaskSet().validPositions[i] == undefined) i++;
					if ((getMaskSet().validPositions[i] !== undefined || !isMask(i)) && s === undefined) {
						var t = getTestTemplate(i);
						if (positionCanMatchDefinition(startPos, t.match.def)) {
							if (isValid(startPos, t.input || getPlaceholder(i), true) !== false) {
								delete getMaskSet().validPositions[i];
								i++;
							}
						} else if (!isMask(i)) {
							i++;
							startPos--;
						}
						startPos++;
					} else i++;
				}
				//remove radixpoint if needed
				var lvp = getLastValidPosition(),
					ml = getMaskLength();
				if (strict !== true && nocheck !== true && getMaskSet().validPositions[lvp] !== undefined && getMaskSet().validPositions[lvp].input === opts.radixPoint) {
					delete getMaskSet().validPositions[lvp];
				}

				for (i = lvp + 1; i <= ml; i++) {
					if (getMaskSet().validPositions[i]) {
						delete getMaskSet().validPositions[i];
					}
				}

				resetMaskSet(true);
			}

			function getTestTemplate(pos, ndxIntlzr, tstPs) {
				var testPos = getMaskSet().validPositions[pos];
				if (testPos === undefined) {
					var testPositions = getTests(pos, ndxIntlzr, tstPs),
						lvp = getLastValidPosition(),
						lvTest = getMaskSet().validPositions[lvp] || getTests(0)[0],
						lvTestAltArr = (lvTest.alternation !== undefined) ? lvTest.locator[lvTest.alternation].toString().split(",") : [];
					for (var ndx = 0; ndx < testPositions.length; ndx++) {
						testPos = testPositions[ndx];

						if (testPos.match &&
							(((opts.greedy && testPos.match.optionalQuantifier !== true) || (testPos.match.optionality === false || testPos.match.newBlockMarker === false) && testPos.match.optionalQuantifier !== true) &&
								((lvTest.alternation === undefined || lvTest.alternation !== testPos.alternation) ||
									(testPos.locator[lvTest.alternation] !== undefined && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAltArr))))) {
							break;
						}
					}
				}

				return testPos;
			}

			function getTest(pos) {
				if (getMaskSet().validPositions[pos]) {
					return getMaskSet().validPositions[pos].match;
				}
				return getTests(pos)[0].match;
			}

			function positionCanMatchDefinition(pos, def) {
				var valid = false,
					tests = getTests(pos);
				for (var tndx = 0; tndx < tests.length; tndx++) {
					if (tests[tndx].match && tests[tndx].match.def === def) {
						valid = true;
						break;
					}
				}
				return valid;
			}

			function selectBestMatch(pos, alternateNdx) {
				var bestMatch, indexPos;
				if (getMaskSet().tests[pos] || getMaskSet().validPositions[pos]) {
					$.each(getMaskSet().tests[pos] || [getMaskSet().validPositions[pos]], function(ndx, lmnt) {
						var ndxPos = lmnt.alternation ? lmnt.locator[lmnt.alternation].toString().indexOf(alternateNdx) : -1;
						if ((indexPos === undefined || ndxPos < indexPos) && ndxPos !== -1) {
							bestMatch = lmnt;
							indexPos = ndxPos;
						}
					});
				}
				return bestMatch;
			}

			function getTests(pos, ndxIntlzr, tstPs, cacheable) {
				var maskTokens = getMaskSet().maskToken,
					testPos = ndxIntlzr ? tstPs : 0,
					ndxInitializer = ndxIntlzr || [0],
					matches = [],
					insertStop = false,
					latestMatch, isFirstMatch;

				function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) { //ndxInitializer contains a set of indexes to speedup searches in the mtokens
					function handleMatch(match, loopNdx, quantifierRecurse) {
						function resolveNdxInitializer(pos, alternateNdx) {
							var bestMatch = selectBestMatch(pos, alternateNdx);
							return bestMatch ? bestMatch.locator.slice(bestMatch.alternation + 1) : [];
						}
						if (testPos > 10000) {
							throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + getMaskSet().mask;
						}
						if (testPos === pos && match.matches === undefined) {
							matches.push({
								"match": match,
								"locator": loopNdx.reverse()
							});
							return true;
						} else if (match.matches !== undefined) {
							if (match.isGroup && quantifierRecurse !== match) { //when a group pass along to the quantifier
								match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx);
								if (match) return true;
							} else if (match.isOptional) {
								var optionalToken = match;
								match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);
								if (match) {
									latestMatch = matches[matches.length - 1].match;
									isFirstMatch = $.inArray(latestMatch, optionalToken.matches) === 0;
									if (isFirstMatch) {
										insertStop = true; //insert a stop
										testPos = pos; //match the position after the group
									} else return true;
								}
							} else if (match.isAlternator) {
								var alternateToken = match,
									malternateMatches = [],
									maltMatches,
									currentMatches = matches.slice(),
									loopNdxCnt = loopNdx.length;
								var altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;
								if (altIndex === -1 || typeof altIndex === "string") {
									var currentPos = testPos,
										ndxInitializerClone = ndxInitializer.slice(),
										altIndexArr = [],
										amndx;
									if (typeof altIndex == "string") {
										altIndexArr = altIndex.split(",");
									} else {
										for (amndx = 0; amndx < alternateToken.matches.length; amndx++) {
											altIndexArr.push(amndx);
										}
									}
									for (var ndx = 0; ndx < altIndexArr.length; ndx++) {
										amndx = parseInt(altIndexArr[ndx]);
										matches = [];
										//set the correct ndxInitializer
										ndxInitializer = resolveNdxInitializer(testPos, amndx);
										match = handleMatch(alternateToken.matches[amndx] || maskToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse) || match;
										if (match !== true && match !== undefined && (altIndexArr[altIndexArr.length - 1] < alternateToken.matches.length)) { //no match in the alternations (length mismatch) => look further
											var ntndx = maskToken.matches.indexOf(match) + 1;
											if (maskToken.matches.length > ntndx) {
												match = handleMatch(maskToken.matches[ntndx], [ntndx].concat(loopNdx.slice(1, loopNdx.length)), quantifierRecurse);
												if (match) {
													altIndexArr.push(ntndx.toString());
													$.each(matches, function(ndx, lmnt) {
														lmnt.alternation = loopNdx.length - 1;
													});
												}
											}
										}
										maltMatches = matches.slice();
										testPos = currentPos;
										matches = [];
										//cloneback
										for (var i = 0; i < ndxInitializerClone.length; i++) {
											ndxInitializer[i] = ndxInitializerClone[i];
										}
										//fuzzy merge matches
										for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
											var altMatch = maltMatches[ndx1];
											altMatch.alternation = altMatch.alternation || loopNdxCnt;
											for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {
												var altMatch2 = malternateMatches[ndx2];
												//verify equality
												if (altMatch.match.def === altMatch2.match.def && (typeof altIndex !== "string" || $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr) !== -1)) {
													if (altMatch.match.mask === altMatch2.match.mask) {
														maltMatches.splice(ndx1, 1);
														ndx1--;
													}
													if (altMatch2.locator[altMatch.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) === -1) {
														altMatch2.locator[altMatch.alternation] = altMatch2.locator[altMatch.alternation] + "," + altMatch.locator[altMatch.alternation];
														altMatch2.alternation = altMatch.alternation; //we pass the alternation index => used in determineLastRequiredPosition
													}
													break;
												}
											}
										}
										malternateMatches = malternateMatches.concat(maltMatches);
									}

									if (typeof altIndex == "string") { //filter matches
										malternateMatches = $.map(malternateMatches, function(lmnt, ndx) {
											if (isFinite(ndx)) {
												var mamatch,
													alternation = lmnt.alternation,
													altLocArr = lmnt.locator[alternation].toString().split(",");
												lmnt.locator[alternation] = undefined;
												lmnt.alternation = undefined;
												for (var alndx = 0; alndx < altLocArr.length; alndx++) {
													mamatch = $.inArray(altLocArr[alndx], altIndexArr) !== -1;
													if (mamatch) { //rebuild the locator with valid entries
														if (lmnt.locator[alternation] !== undefined) {
															lmnt.locator[alternation] += ",";
															lmnt.locator[alternation] += altLocArr[alndx];
														} else lmnt.locator[alternation] = parseInt(altLocArr[alndx]);

														lmnt.alternation = alternation;
													}
												}
												if (lmnt.locator[alternation] !== undefined) return lmnt;
											}
										});
									}

									matches = currentMatches.concat(malternateMatches);
									testPos = pos;
									insertStop = matches.length > 0; //insert a stopelemnt when there is an alternate - needed for non-greedy option
								} else {
									// if (alternateToken.matches[altIndex]) { //if not in the initial alternation => look further
									match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);
									// } else match = false;
								}
								if (match) return true;
							} else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) {
								var qt = match;
								for (var qndx = (ndxInitializer.length > 0) ? ndxInitializer.shift() : 0;
									(qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max)) && testPos <= pos; qndx++) {
									var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];
									match = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup); //set the tokenGroup as quantifierRecurse marker
									if (match) {
										//get latest match
										latestMatch = matches[matches.length - 1].match;
										latestMatch.optionalQuantifier = qndx > (qt.quantifier.min - 1);
										isFirstMatch = $.inArray(latestMatch, tokenGroup.matches) === 0;

										if (isFirstMatch) { //search for next possible match
											if (qndx > (qt.quantifier.min - 1)) {
												insertStop = true;
												testPos = pos; //match the position after the group
												break; //stop quantifierloop
											} else return true;
										} else {
											return true;
										}
									}
								}
							} else {
								match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);
								if (match) return true;
							}
						} else testPos++;
					}

					for (var tndx = (ndxInitializer.length > 0 ? ndxInitializer.shift() : 0); tndx < maskToken.matches.length; tndx++) {
						if (maskToken.matches[tndx].isQuantifier !== true) {
							var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);
							if (match && testPos === pos) {
								return match;
							} else if (testPos > pos) {
								break;
							}
						}
					}
				}

				if (pos > -1) {
					if (cacheable === true && getMaskSet().tests[pos]) {
						return getMaskSet().tests[pos];
					}
					if (ndxIntlzr === undefined) {
						var previousPos = pos - 1,
							test;
						while ((test = getMaskSet().validPositions[previousPos]) === undefined && previousPos > -1) {
							if (getMaskSet().tests[previousPos] && (test = getMaskSet().tests[previousPos][0]) !== undefined) {
								break;
							}
							previousPos--;

						}
						if (test !== undefined && previousPos > -1) {
							testPos = previousPos;
							ndxInitializer = test.locator.slice();
						}
					}
					for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {
						var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);
						if ((match && testPos === pos) || testPos > pos) {
							break;
						}
					}
				}
				if (matches.length === 0 || insertStop) {
					matches.push({
						"match": {
							fn: null,
							cardinality: 0,
							optionality: true,
							casing: null,
							def: ""
						},
						"locator": []
					});
				}
				getMaskSet().tests[pos] = $.extend(true, [], matches); //set a clone to prevent overwriting some props
				// console.log(pos + " - " + JSON.stringify(matches));
				return getMaskSet().tests[pos];
			}

			function getBufferTemplate() {
				if (getMaskSet()._buffer === undefined) {
					//generate template
					getMaskSet()._buffer = getMaskTemplate(false, 1);
				}
				return getMaskSet()._buffer;
			}

			function getBuffer(noCache) {
				if (getMaskSet().buffer === undefined || noCache === true) {
					if (noCache === true) {
						for (var testNdx in getMaskSet().tests) {
							if (getMaskSet().validPositions[testNdx] === undefined) {
								delete getMaskSet().tests[testNdx];
							}
						}
					}
					getMaskSet().buffer = getMaskTemplate(true, getLastValidPosition(), true);
				}
				return getMaskSet().buffer;
			}

			function refreshFromBuffer(start, end, buffer) {
				var i;
				buffer = buffer;
				if (start === true) {
					resetMaskSet();
					start = 0;
					end = buffer.length;
				} else {
					for (i = start; i < end; i++) {
						delete getMaskSet().validPositions[i];
						delete getMaskSet().tests[i];
					}
				}
				for (i = start; i < end; i++) {
					resetMaskSet(true); //prevents clobber from the buffer
					if (buffer[i] !== opts.skipOptionalPartCharacter) {
						isValid(i, buffer[i], true, true);
					}
				}
			}

			function casing(elem, test) {
				switch (test.casing) {
					case "upper":
						elem = elem.toUpperCase();
						break;
					case "lower":
						elem = elem.toLowerCase();
						break;
				}

				return elem;
			}

			function checkAlternationMatch(altArr1, altArr2) {
				var altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1),
					isMatch = false;
				for (var alndx = 0; alndx < altArr1.length; alndx++) {
					if ($.inArray(altArr1[alndx], altArrC) !== -1) {
						isMatch = true;
						break;
					}
				}
				return isMatch;
			}

			function isValid(pos, c, strict, fromSetValid) { //strict true ~ no correction or autofill
				strict = strict === true; //always set a value to strict to prevent possible strange behavior in the extensions

				function _isValid(position, c, strict, fromSetValid) {
					var rslt = false;
					$.each(getTests(position), function(ndx, tst) {
						var test = tst.match;
						var loopend = c ? 1 : 0,
							chrs = "";
						for (var i = test.cardinality; i > loopend; i--) {
							chrs += getBufferElement(position - (i - 1));
						}
						if (c) {
							chrs += c;
						}

						//make sure the buffer is set and correct
						getBuffer(true);
						//return is false or a json object => { pos: ??, c: ??} or true
						rslt = test.fn != null ?
							test.fn.test(chrs, getMaskSet(), position, strict, opts) : (c === test.def || c === opts.skipOptionalPartCharacter) && test.def !== "" ? //non mask
							{
								c: test.placeholder || test.def,
								pos: position
							} : false;

						if (rslt !== false) {
							var elem = rslt.c !== undefined ? rslt.c : c;
							elem = (elem === opts.skipOptionalPartCharacter && test.fn === null) ? (test.placeholder || test.def) : elem;

							var validatedPos = position,
								possibleModifiedBuffer = getBuffer();

							if (rslt.remove !== undefined) { //remove position(s)
								if (!$.isArray(rslt.remove)) rslt.remove = [rslt.remove];
								$.each(rslt.remove.sort(function(a, b) {
									return b - a;
								}), function(ndx, lmnt) {
									stripValidPositions(lmnt, lmnt + 1, true);
								});
							}
							if (rslt.insert !== undefined) { //insert position(s)
								if (!$.isArray(rslt.insert)) rslt.insert = [rslt.insert];
								$.each(rslt.insert.sort(function(a, b) {
									return a - b;
								}), function(ndx, lmnt) {
									isValid(lmnt.pos, lmnt.c, true);
								});
							}

							if (rslt.refreshFromBuffer) {
								var refresh = rslt.refreshFromBuffer;
								strict = true;
								refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, possibleModifiedBuffer);
								if (rslt.pos === undefined && rslt.c === undefined) {
									rslt.pos = getLastValidPosition();
									return false; //breakout if refreshFromBuffer && nothing to insert
								}
								validatedPos = rslt.pos !== undefined ? rslt.pos : position;
								if (validatedPos !== position) {
									rslt = $.extend(rslt, isValid(validatedPos, elem, true)); //revalidate new position strict
									return false;
								}

							} else if (rslt !== true && rslt.pos !== undefined && rslt.pos !== position) { //their is a position offset
								validatedPos = rslt.pos;
								refreshFromBuffer(position, validatedPos, getBuffer().slice());
								if (validatedPos !== position) {
									rslt = $.extend(rslt, isValid(validatedPos, elem, true)); //revalidate new position strict
									return false;
								}
							}

							if (rslt !== true && rslt.pos === undefined && rslt.c === undefined) {
								return false; //breakout if nothing to insert
							}

							if (ndx > 0) {
								resetMaskSet(true);
							}

							if (!setValidPosition(validatedPos, $.extend({}, tst, {
									"input": casing(elem, test)
								}), fromSetValid)) {
								rslt = false;
							}
							return false; //break from $.each
						}
					});

					return rslt;
				}

				function alternate(pos, c, strict, fromSetValid) {
					var validPsClone = $.extend(true, {}, getMaskSet().validPositions),
						testsClone = $.extend(true, {}, getMaskSet().tests),
						lastAlt,
						alternation,
						isValidRslt,
						altPos, i, validPos;
					//find last modified alternation
					for (var lAlt = getLastValidPosition(); lAlt >= 0; lAlt--) {
						altPos = getMaskSet().validPositions[lAlt];
						if (altPos && altPos.alternation !== undefined) {
							lastAlt = lAlt;
							alternation = getMaskSet().validPositions[lastAlt].alternation;
							if (getTestTemplate(lastAlt).locator[altPos.alternation] !== altPos.locator[altPos.alternation]) {
								break;
							}
						}
					}
					if (alternation !== undefined) {
						//find first decision making position
						lastAlt = parseInt(lastAlt);
						for (var decisionPos in getMaskSet().validPositions) {
							decisionPos = parseInt(decisionPos);
							altPos = getMaskSet().validPositions[decisionPos];
							if (decisionPos >= lastAlt && altPos.alternation !== undefined) {
								var altNdxs;
								if (lastAlt === 0) {
									altNdxs = [];
									$.each(getMaskSet().tests[lastAlt], function(ndx, test) {
										if (test.locator[alternation] !== undefined) {
											altNdxs = altNdxs.concat(test.locator[alternation].toString().split(","));
										}
									});
								} else {
									altNdxs = getMaskSet().validPositions[lastAlt].locator[alternation].toString().split(",");
								}
								var decisionTaker = altPos.locator[alternation] !== undefined ? altPos.locator[alternation] : altNdxs[0]; //no match in the alternations (length mismatch)
								if (decisionTaker.length > 0) { //no decision taken ~ take first one as decider
									decisionTaker = decisionTaker.split(",")[0];
								}

								for (var mndx = 0; mndx < altNdxs.length; mndx++) {
									var validInputs = [],
										staticInputsBeforePos = 0,
										staticInputsBeforePosAlternate = 0;
									if (decisionTaker < altNdxs[mndx]) {
										var possibilityPos, possibilities;
										for (var dp = decisionPos; dp >= 0; dp--) {
											possibilityPos = getMaskSet().validPositions[dp];
											if (possibilityPos !== undefined) {
												var bestMatch = selectBestMatch(dp, altNdxs[mndx]);
												if (getMaskSet().validPositions[dp].match.def !== bestMatch.match.def) {
													validInputs.push(getMaskSet().validPositions[dp].input);
													getMaskSet().validPositions[dp] = bestMatch;
													getMaskSet().validPositions[dp].input = getPlaceholder(dp);
													if (getMaskSet().validPositions[dp].match.fn === null) {
														staticInputsBeforePosAlternate++;
													}
													possibilityPos = bestMatch;
												}
												possibilities = possibilityPos.locator[alternation]; //store to reset
												possibilityPos.locator[alternation] = parseInt(altNdxs[mndx]);
												break;
											}
										}
										if (decisionTaker !== possibilityPos.locator[alternation]) {
											for (i = decisionPos + 1; i < getLastValidPosition(undefined, true) + 1; i++) {
												validPos = getMaskSet().validPositions[i];
												if (validPos && validPos.match.fn != null) {
													validInputs.push(validPos.input);
												} else if (i < pos) staticInputsBeforePos++;
												delete getMaskSet().validPositions[i];
												delete getMaskSet().tests[i];
											}
											resetMaskSet(true); //clear getbuffer
											opts.keepStatic = !opts.keepStatic; //disable keepStatic on getMaskLength
											isValidRslt = true;
											while (validInputs.length > 0) {
												var input = validInputs.shift();
												if (input !== opts.skipOptionalPartCharacter) {
													if (!(isValidRslt = isValid(getLastValidPosition(undefined, true) + 1, input, false, true))) {
														break;
													}
												}
											}

											possibilityPos.alternation = alternation;
											possibilityPos.locator[alternation] = possibilities; //reset forceddecision ~ needed for proper delete
											if (isValidRslt) {
												var targetLvp = getLastValidPosition(pos) + 1;
												for (i = decisionPos + 1; i < getLastValidPosition() + 1; i++) {
													validPos = getMaskSet().validPositions[i];
													if ((validPos === undefined || validPos.match.fn == null) && i < pos) {
														staticInputsBeforePosAlternate++;
													}
												}
												pos = pos + (staticInputsBeforePosAlternate - staticInputsBeforePos);
												isValidRslt = isValid(pos > targetLvp ? targetLvp : pos, c, strict, fromSetValid);
											}
											opts.keepStatic = !opts.keepStatic; //enable keepStatic on getMaskLength
											if (!isValidRslt) {
												resetMaskSet();
												getMaskSet().validPositions = $.extend(true, {}, validPsClone);
												getMaskSet().tests = $.extend(true, {}, testsClone);
											} else return isValidRslt;
										}
									}
								}
								break;
							}
						}
					}
					return false;
				}

				//set alternator choice on previous skipped placeholder positions
				function trackbackAlternations(originalPos, newPos) {
					var vp = getMaskSet().validPositions[newPos],
						targetLocator = vp.locator,
						tll = targetLocator.length;

					for (var ps = originalPos; ps < newPos; ps++) {
						if (getMaskSet().validPositions[ps] === undefined && !isMask(ps, true)) {
							var tests = getTests(ps),
								bestMatch = tests[0],
								equality = -1;
							$.each(tests, function(ndx, tst) { //find best matching
								for (var i = 0; i < tll; i++) {
									if (tst.locator[i] !== undefined && checkAlternationMatch(tst.locator[i].toString().split(","), targetLocator[i].toString().split(","))) {
										if (equality < i) {
											equality = i;
											bestMatch = tst;
										}
									} else break;
								}
							});
							setValidPosition(ps, $.extend({}, bestMatch, {
								"input": bestMatch.match.placeholder || bestMatch.match.def
							}), true);
						}
					}
				}
				//Check for a nonmask before the pos
				var buffer = getBuffer();

				//find previous valid
				for (var pndx = pos - 1; pndx > -1; pndx--) {
					if (getMaskSet().validPositions[pndx]) {
						break;
					}
				}
				////fill missing nonmask and valid placeholders
				pndx++;
				for (; pndx < pos; pndx++) {
					//console.log("missing " + pndx + " " + buffer[pndx] + " ismask " + isMask(pndx) + " plchldr " + getPlaceholder(pndx) + " nrt " + getTests(pndx).len);
					if (getMaskSet().validPositions[pndx] === undefined && (((!isMask(pndx) || buffer[pndx] !== getPlaceholder(pndx)) && getTests(pndx).length > 1) || (buffer[pndx] === opts.radixPoint || buffer[pndx] === "0" && $.inArray(opts.radixPoint, buffer) < pndx))) //special case for decimals ~ = placeholder but yet valid input
					{
						//console.log("inject " + pndx + " " + buffer[pndx]);
						_isValid(pndx, buffer[pndx], true);
					}
				}

				var maskPos = pos,
					result = false,
					positionsClone = $.extend(true, {}, getMaskSet().validPositions); //clone the currentPositions

				//if (fromSetValid && maskPos >= getMaskLength()) {
				//		resetMaskSet(true); //masklenght can be altered on the process => reset to get the actual length
				//}
				if (maskPos < getMaskLength()) {
					result = _isValid(maskPos, c, strict, fromSetValid);
					if ((!strict || fromSetValid) && result === false) {
						var currentPosValid = getMaskSet().validPositions[maskPos];
						if (currentPosValid && currentPosValid.match.fn === null && (currentPosValid.match.def === c || c === opts.skipOptionalPartCharacter)) {
							result = {
								"caret": seekNext(maskPos)
							};
						} else if ((opts.insertMode || getMaskSet().validPositions[seekNext(maskPos)] === undefined) && !isMask(maskPos, true)) { //does the input match on a further position?
							var staticChar = getTestTemplate(maskPos).match,
								staticChar = staticChar.placeholder || staticChar.def;
							_isValid(maskPos, staticChar, strict, fromSetValid);
							for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) {
								result = _isValid(nPos, c, strict, fromSetValid);
								if (result !== false) {
									trackbackAlternations(maskPos, nPos);
									maskPos = nPos;
									break;
								}
							}
						}
					}
				}
				if (result === false && opts.keepStatic) { //try fuzzy alternator logic
					result = alternate(pos, c, strict, fromSetValid);
				}
				if (result === true) {
					result = {
						"pos": maskPos
					};
				}
				if ($.isFunction(opts.postValidation) && result !== false && !strict) {
					var postValidResult = opts.postValidation(getBuffer(true), opts);
					if (!postValidResult) {
						resetMaskSet(true);
						getMaskSet().validPositions = $.extend(true, {}, positionsClone); //revert validation changes
						result = false;
					} else if (postValidResult.refreshFromBuffer) {
						var refresh = postValidResult.refreshFromBuffer;
						refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, postValidResult.buffer);
						resetMaskSet(true);
						result = postValidResult;
					}
				}

				return result;
			}

			function isMask(pos, strict) {
				var test;
				if (strict) {
					test = getTestTemplate(pos).match;
					if (test.def == "") test = getTest(pos);
				} else test = getTest(pos);

				if (test.fn != null) {
					return test.fn;
				} else if (strict !== true && pos > -1 && !opts.keepStatic && getMaskSet().validPositions[pos] === undefined) {
					var tests = getTests(pos, undefined, undefined, true);
					return tests.length > 2;
				}
				return false;
			}

			function getMaskLength() {
				var maskLength;
				maxLength = el !== undefined ? el.maxLength : undefined;
				if (maxLength === -1) maxLength = undefined; /* FF sets no defined max length to -1 */
				var pos, lvp = getLastValidPosition(),
					testPos = getMaskSet().validPositions[lvp],
					ndxIntlzr = testPos !== undefined ? testPos.locator.slice() : undefined;
				for (pos = lvp + 1; testPos === undefined || (testPos.match.fn !== null || (testPos.match.fn === null && testPos.match.def !== "")); pos++) {
					testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
					ndxIntlzr = testPos.locator.slice();
				}

				var lastTest = getTest(pos - 1);
				maskLength = (lastTest.def !== "") ? pos : pos - 1;
				return (maxLength === undefined || maskLength < maxLength) ? maskLength : maxLength;
			}

			function seekNext(pos, newBlock) {
				var maskL = getMaskLength();
				if (pos >= maskL) return maskL;
				var position = pos;
				while (++position < maskL && ((newBlock === true && (getTest(position).newBlockMarker !== true || !isMask(position))) || (newBlock !== true && !isMask(position) && (opts.nojumps !== true || opts.nojumpsThreshold > position)))) {}
				return position;
			}

			function seekPrevious(pos, newBlock) {
				var position = pos;
				if (position <= 0) return 0;

				while (--position > 0 && ((newBlock === true && getTest(position).newBlockMarker !== true) || (newBlock !== true && !isMask(position)))) {}

				return position;
			}

			function getBufferElement(position) {
				return getMaskSet().validPositions[position] === undefined ? getPlaceholder(position) : getMaskSet().validPositions[position].input;
			}

			function writeBuffer(input, buffer, caretPos, event, triggerInputEvent) {
				if (event && $.isFunction(opts.onBeforeWrite)) {
					var result = opts.onBeforeWrite(event, buffer, caretPos, opts);
					if (result) {
						if (result.refreshFromBuffer) {
							var refresh = result.refreshFromBuffer;
							refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, result.buffer || buffer);
							buffer = getBuffer(true);
						}
						//only alter when intented !== undefined
						if (caretPos !== undefined) caretPos = result.caret !== undefined ? result.caret : caretPos;
					}
				}
				input.inputmask._valueSet(buffer.join(""));
				if (caretPos !== undefined && (event === undefined || event.type !== "blur")) {
					caret(input, caretPos);
				}
				if (triggerInputEvent === true) {
					skipInputEvent = true;
					$(input).trigger("input");
				}
			}

			function getPlaceholder(pos, test) {
				test = test || getTest(pos);
				if (test.placeholder !== undefined) {
					return test.placeholder;
				} else if (test.fn === null) {
					if (pos > -1 && !opts.keepStatic && getMaskSet().validPositions[pos] === undefined) {
						var tests = getTests(pos),
							staticAlternations = 0,
							prevTest;
						if (tests.length > 2) {
							for (var i = 0; i < tests.length; i++) {
								if (tests[i].match.optionality !== true && tests[i].match.optionalQuantifier !== true &&
									(tests[i].match.fn === null || (prevTest === undefined || tests[i].match.fn.test(prevTest.match.def, getMaskSet(), pos, true, opts) !== false))) {
									staticAlternations++;
									if (tests[i].match.fn === null) prevTest = tests[i];
									if (staticAlternations > 1) return opts.placeholder.charAt(pos % opts.placeholder.length);
								}
							}
						}
					}
					return test.def;
				}
				return opts.placeholder.charAt(pos % opts.placeholder.length);
			}

			function checkVal(input, writeOut, strict, nptvl) {
				var inputValue = nptvl.slice(),
					charCodes = "",
					initialNdx = 0;

				function isTemplateMatch() {
					var isMatch = false;
					var charCodeNdx = getBufferTemplate().slice(initialNdx, seekNext(initialNdx)).join("").indexOf(charCodes);
					if (charCodeNdx !== -1 && !isMask(initialNdx)) {
						isMatch = true;
						var bufferTemplateArr = getBufferTemplate().slice(initialNdx, initialNdx + charCodeNdx);
						for (var i = 0; i < bufferTemplateArr.length; i++) {
							if (bufferTemplateArr[i] !== " ") {
								isMatch = false;
								break;
							}
						}
					}

					return isMatch;
				}
				resetMaskSet();
				getMaskSet().p = seekNext(-1);
				// if (writeOut) input.inputmask._valueSet(""); //initial clear

				if (!strict) {
					if (opts.autoUnmask !== true) {
						var staticInput = getBufferTemplate().slice(0, seekNext(-1)).join(""),
							matches = inputValue.join("").match(new RegExp("^" + Inputmask.escapeRegex(staticInput), "g"));
						if (matches && matches.length > 0) {
							inputValue.splice(0, matches.length * staticInput.length);
							initialNdx = seekNext(initialNdx);
						}
					} else {
						initialNdx = seekNext(initialNdx);
					}
				}


				$.each(inputValue, function(ndx, charCode) {
					var keypress = new $.Event("keypress");
					keypress.which = charCode.charCodeAt(0);
					charCodes += charCode;
					var lvp = getLastValidPosition(undefined, true),
						lvTest = getMaskSet().validPositions[lvp],
						nextTest = getTestTemplate(lvp + 1, lvTest ? lvTest.locator.slice() : undefined, lvp);
					if (!isTemplateMatch() || strict || opts.autoUnmask) {
						var pos = strict ? ndx : (nextTest.match.fn == null && nextTest.match.optionality && (lvp + 1) < getMaskSet().p ? lvp + 1 : getMaskSet().p);
						keypressEvent.call(input, keypress, true, false, strict, pos);
						initialNdx = pos + 1;
						charCodes = "";
					} else {
						keypressEvent.call(input, keypress, true, false, true, lvp + 1);
					}
				});
				if (writeOut) {
					writeBuffer(input, getBuffer(), document.activeElement === input ? seekNext(getLastValidPosition(0)) : undefined, new $.Event("checkval"));
				}
			}

			function unmaskedvalue(input) {
				if (input && input.inputmask === undefined) {
					return input.value;
				}

				var umValue = [],
					vps = getMaskSet().validPositions;
				for (var pndx in vps) {
					if (vps[pndx].match && vps[pndx].match.fn != null) {
						umValue.push(vps[pndx].input);
					}
				}
				var unmaskedValue = umValue.length === 0 ? null : (isRTL ? umValue.reverse() : umValue).join("");
				if (unmaskedValue !== null) {
					var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join("");
					if ($.isFunction(opts.onUnMask)) {
						unmaskedValue = (opts.onUnMask(bufferValue, unmaskedValue, opts) || unmaskedValue);
					}
				}
				return unmaskedValue;
			}

			function caret(input, begin, end) {
				function translatePosition(pos) {
					if (isRTL && typeof pos === "number" && (!opts.greedy || opts.placeholder !== "")) {
						var bffrLght = getBuffer().join("").length; //join is needed because sometimes we get an empty buffer element which must not be counted for the caret position (numeric alias)
						pos = bffrLght - pos;
					}
					return pos;
				}
				var range;
				if (typeof begin === "number") {
					begin = translatePosition(begin);
					end = translatePosition(end);
					end = (typeof end == "number") ? end : begin;
					// if (!$(input).is(":visible")) {
					// 	return;
					// }

					var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;
					input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0;
					if (!androidchrome && opts.insertMode === false && begin === end) end++; //set visualization for insert/overwrite mode
					if (input.setSelectionRange) {
						input.selectionStart = begin;
						input.selectionEnd = end;
					} else if (window.getSelection) {
						range = document.createRange();
						if (input.firstChild === undefined) {
							var textNode = document.createTextNode("");
							input.appendChild(textNode);
						}
						range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length);
						range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length);
						range.collapse(true);
						var sel = window.getSelection();
						sel.removeAllRanges();
						sel.addRange(range);
						//input.focus();
					} else if (input.createTextRange) {
						range = input.createTextRange();
						range.collapse(true);
						range.moveEnd("character", end);
						range.moveStart("character", begin);
						range.select();

					}
				} else {
					if (input.setSelectionRange) {
						begin = input.selectionStart;
						end = input.selectionEnd;
					} else if (window.getSelection) {
						range = window.getSelection().getRangeAt(0);
						if (range.commonAncestorContainer.parentNode === input || range.commonAncestorContainer === input) {
							begin = range.startOffset;
							end = range.endOffset;
						}
					} else if (document.selection && document.selection.createRange) {
						range = document.selection.createRange();
						begin = 0 - range.duplicate().moveStart("character", -100000);
						end = begin + range.text.length;
					}
					/*eslint-disable consistent-return */
					return {
						"begin": translatePosition(begin),
						"end": translatePosition(end)
					};
					/*eslint-enable consistent-return */
				}
			}

			function determineLastRequiredPosition(returnDefinition) {
				var buffer = getBuffer(),
					bl = buffer.length,
					pos, lvp = getLastValidPosition(),
					positions = {},
					lvTest = getMaskSet().validPositions[lvp],
					ndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined,
					testPos;
				for (pos = lvp + 1; pos < buffer.length; pos++) {
					testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
					ndxIntlzr = testPos.locator.slice();
					positions[pos] = $.extend(true, {}, testPos);
				}

				var lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;
				for (pos = bl - 1; pos > lvp; pos--) {
					testPos = positions[pos];
					if ((testPos.match.optionality ||
							testPos.match.optionalQuantifier ||
							(lvTestAlt && ((lvTestAlt !== positions[pos].locator[lvTest.alternation] && testPos.match.fn != null) ||
								(testPos.match.fn === null && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAlt.toString().split(",")) && getTests(pos)[0].def !== "")))) && buffer[pos] === getPlaceholder(pos, testPos.match)) {
						bl--;
					} else break;
				}
				return returnDefinition ? {
					"l": bl,
					"def": positions[bl] ? positions[bl].match : undefined
				} : bl;
			}

			function clearOptionalTail(buffer) {
				var rl = determineLastRequiredPosition(),
					lmib = buffer.length - 1;
				for (; lmib > rl; lmib--) {
					if (isMask(lmib)) break; //fixme ismask is not good enough
				}
				buffer.splice(rl, lmib + 1 - rl);

				return buffer;
			}

			function isComplete(buffer) { //return true / false / undefined (repeat *)
				if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);
				if (opts.repeat === "*") return undefined;
				var complete = false,
					lrp = determineLastRequiredPosition(true),
					aml = seekPrevious(lrp.l);

				if (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
					complete = true;
					for (var i = 0; i <= aml; i++) {
						var test = getTestTemplate(i).match;
						if ((test.fn !== null && getMaskSet().validPositions[i] === undefined && test.optionality !== true && test.optionalQuantifier !== true) || (test.fn === null && buffer[i] !== getPlaceholder(i, test))) {
							complete = false;
							break;
						}
					}
				}
				return complete;
			}

			function isSelection(begin, end) {
				return isRTL ? (begin - end) > 1 || ((begin - end) === 1 && opts.insertMode) :
					(end - begin) > 1 || ((end - begin) === 1 && opts.insertMode);
			}

			var EventRuler = {
				on: function(input, eventName, eventHandler) {
					var ev = function(e) {
						// console.log("triggered " + e.type);
						var inComposition = false,
							keydownPressed = false;
						if (this.inputmask === undefined) { //happens when cloning an object with jquery.clone
							var imOpts = $.data(this, "_inputmask_opts");
							if (imOpts)(new Inputmask(imOpts)).mask(this);
							else EventRuler.off(this);
						} else if (e.type !== "setvalue" && (this.disabled || (this.readOnly && !(e.type === "keydown" && (e.ctrlKey && e.keyCode === 67) || (opts.tabThrough === false && e.keyCode === Inputmask.keyCode.TAB))))) {
							e.preventDefault();
						} else {
							switch (e.type) {
								case "input":
									if (skipInputEvent === true || inComposition === true) {
										skipInputEvent = false;
										return e.preventDefault();
									}
									keydownPressed = false;
									break;
								case "keydown":
									//Safari 5.1.x - modal dialog fires keypress twice workaround
									skipKeyPressEvent = false;
									inComposition = false;
									keydownPressed = true;
									break;
								case "keypress":
									if (skipKeyPressEvent === true) {
										return e.preventDefault();
									}
									skipKeyPressEvent = true;

									break;
								case "compositionstart":
									inComposition = true;
									break;
								case "compositionupdate":
									skipInputEvent = keydownPressed;
									break;
								case "compositionend":
									inComposition = false;
									keydownPressed = false;
									break;
								case "cut":
									skipInputEvent = true;
									break;
							}
							// console.log("executed " + e.type);
							return eventHandler.apply(this, arguments);
						}
					};
					//keep instance of the event
					input.inputmask.events[eventName] = input.inputmask.events[eventName] || [];
					input.inputmask.events[eventName].push(ev);

					if (["submit", "reset"].indexOf(eventName) != -1) {
						if (input.form != null) $(input.form).on(eventName, ev);
					} else {
						$(input).on(eventName, ev);
					}
				},
				off: function(input, event) {
					if (input.inputmask && input.inputmask.events) {
						var events;
						event ? (events = [], events[event] = input.inputmask.events[event]) : events = input.inputmask.events;
						$.each(events, function(eventName, evArr) {
							while (evArr.length > 0) {
								var ev = evArr.pop();
								if (["submit", "reset"].indexOf(eventName) !== -1) {
									if (input.form != null) $(input.form).off(eventName, ev);
								} else {
									$(input).off(eventName, ev);
								}
							}
							delete input.inputmask.events[eventName];
						})
					}
				}
			}

			function patchValueProperty(npt) {
				var valueGet;
				var valueSet;

				function patchValhook(type) {
					if ($.valHooks && ($.valHooks[type] === undefined || $.valHooks[type].inputmaskpatch !== true)) {
						var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function(elem) {
							return elem.value;
						};
						var valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function(elem, value) {
							elem.value = value;
							return elem;
						};

						$.valHooks[type] = {
							get: function(elem) {
								if (elem.inputmask) {
									if (elem.inputmask.opts.autoUnmask) {
										return elem.inputmask.unmaskedvalue();
									} else {
										var result = valhookGet(elem),
											maskset = elem.inputmask.maskset,
											bufferTemplate = maskset._buffer;
										bufferTemplate = bufferTemplate ? bufferTemplate.join("") : "";
										return result !== bufferTemplate ? result : "";
									}
								} else return valhookGet(elem);
							},
							set: function(elem, value) {
								var $elem = $(elem),
									result;
								result = valhookSet(elem, value);
								if (elem.inputmask) {
									$elem.trigger("setvalue");
								}
								return result;
							},
							inputmaskpatch: true
						};
					}
				}

				function getter() {
					if (this.inputmask) {
						return this.inputmask.opts.autoUnmask ?
							this.inputmask.unmaskedvalue() :
							(valueGet.call(this) !== getBufferTemplate().join("") ?
								(document.activeElement === this && opts.clearMaskOnLostFocus ?
									(isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join("") :
									valueGet.call(this)) :
								"");
					} else return valueGet.call(this);
				}

				function setter(value) {
					valueSet.call(this, value);
					if (this.inputmask) {
						$(this).trigger("setvalue");
					}
				}

				function installNativeValueSetFallback(npt) {
					EventRuler.on(npt, "mouseenter", function(event) {
						var $input = $(this),
							input = this,
							value = input.inputmask._valueGet();
						if (value !== "" && value !== getBuffer().join("")) {
							$input.trigger("setvalue");
						}
					});
				}

				if (!npt.inputmask.__valueGet) {
					if (Object.getOwnPropertyDescriptor && npt.value === undefined) { // && npt.isContentEditable) {
						valueGet = function() {
							return this.textContent;
						};
						valueSet = function(value) {
							this.textContent = value;
						};

						Object.defineProperty(npt, "value", {
							get: getter,
							set: setter
						});
					} else if (document.__lookupGetter__ && npt.__lookupGetter__("value")) {
						valueGet = npt.__lookupGetter__("value");
						valueSet = npt.__lookupSetter__("value");

						npt.__defineGetter__("value", getter);
						npt.__defineSetter__("value", setter);
					} else { //jquery.val
						valueGet = function() {
							return npt.value;
						};
						valueSet = function(value) {
							npt.value = value;
						};
						patchValhook(npt.type);
						installNativeValueSetFallback(npt);
					}
					npt.inputmask.__valueGet = valueGet; //store native property getter
					npt.inputmask._valueGet = function(overruleRTL) {
						return isRTL && overruleRTL !== true ? valueGet.call(this.el).split("").reverse().join("") : valueGet.call(this.el);
					};
					npt.inputmask.__valueSet = valueSet; //store native property setter
					npt.inputmask._valueSet = function(value, overruleRTL) { //null check is needed for IE8 => otherwise converts to "null"
						valueSet.call(this.el, (value === null || value === undefined) ? "" : ((overruleRTL !== true && isRTL) ? value.split("").reverse().join("") : value));
					};
				}
			}

			function handleRemove(input, k, pos, strict) {
				function generalize() {
					if (opts.keepStatic) {
						resetMaskSet(true);
						var validInputs = [],
							lastAlt, positionsClone = $.extend(true, {}, getMaskSet().validPositions);
						//find last alternation
						for (lastAlt = getLastValidPosition(); lastAlt >= 0; lastAlt--) {
							var validPos = getMaskSet().validPositions[lastAlt];
							if (validPos) {
								if (validPos.match.fn != null) {
									validInputs.push(validPos.input);
								}
								delete getMaskSet().validPositions[lastAlt];
								if (validPos.alternation !== undefined && validPos.locator[validPos.alternation] === getTestTemplate(lastAlt).locator[validPos.alternation]) {
									break;
								}
							}
						}

						if (lastAlt > -1) {
							while (validInputs.length > 0) {
								getMaskSet().p = seekNext(getLastValidPosition());
								var keypress = new $.Event("keypress");
								keypress.which = validInputs.pop().charCodeAt(0);
								keypressEvent.call(input, keypress, true, false, false, getMaskSet().p);
							}
						} else getMaskSet().validPositions = $.extend(true, {}, positionsClone); //restore original positions

					}
				}

				if (opts.numericInput || isRTL) {
					if (k === Inputmask.keyCode.BACKSPACE) {
						k = Inputmask.keyCode.DELETE;
					} else if (k === Inputmask.keyCode.DELETE) {
						k = Inputmask.keyCode.BACKSPACE;
					}

					if (isRTL) {
						var pend = pos.end;
						pos.end = pos.begin;
						pos.begin = pend;
					}
				}

				if (k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1 || opts.insertMode === false)) {
					pos.begin = seekPrevious(pos.begin);
					if (getMaskSet().validPositions[pos.begin] !== undefined && (getMaskSet().validPositions[pos.begin].input === opts.groupSeparator || getMaskSet().validPositions[pos.begin].input === opts.radixPoint)) {
						pos.begin--;
					}
				} else if (k === Inputmask.keyCode.DELETE && pos.begin === pos.end) {
					pos.end = isMask(pos.end) ? pos.end + 1 : seekNext(pos.end) + 1;
					if (getMaskSet().validPositions[pos.begin] !== undefined && (getMaskSet().validPositions[pos.begin].input === opts.groupSeparator || getMaskSet().validPositions[pos.begin].input === opts.radixPoint)) {
						pos.end++;
					}
				}

				stripValidPositions(pos.begin, pos.end, false, strict);
				if (strict !== true) {
					generalize(); //revert the alternation
				}
				var lvp = getLastValidPosition(pos.begin);
				if (lvp < pos.begin) {
					if (lvp === -1) resetMaskSet();
					getMaskSet().p = seekNext(lvp);
				} else if (strict !== true) {
					getMaskSet().p = pos.begin;
				}
			}

			function keydownEvent(e) {
				var input = this,
					$input = $(input),
					k = e.keyCode,
					pos = caret(input);

				//backspace, delete, and escape get special treatment
				if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || (iphone && k === 127) || (e.ctrlKey && k === 88 && !isInputEventSupported("cut"))) { //backspace/delete
					e.preventDefault(); //stop default action but allow propagation
					if (k === 88) undoValue = getBuffer().join("");
					handleRemove(input, k, pos);
					writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join(""));
					if (input.inputmask._valueGet() === getBufferTemplate().join("")) {
						$input.trigger("cleared");
					} else if (isComplete(getBuffer()) === true) {
						$input.trigger("complete");
					}
					if (opts.showTooltip) { //update tooltip
						input.title = opts.tooltip || getMaskSet().mask;
					}
				} else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch
					setTimeout(function() {
						var caretPos = seekNext(getLastValidPosition());
						if (!opts.insertMode && caretPos === getMaskLength() && !e.shiftKey) caretPos--;
						caret(input, e.shiftKey ? pos.begin : caretPos, caretPos);
					}, 0);
				} else if ((k === Inputmask.keyCode.HOME && !e.shiftKey) || k === Inputmask.keyCode.PAGE_UP) { //Home or page_up
					caret(input, 0, e.shiftKey ? pos.begin : 0);
				} else if (((opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE) || (k === 90 && e.ctrlKey)) && e.altKey !== true) { //escape && undo && #762
					checkVal(input, true, false, undoValue.split(""));
					$input.trigger("click");
				} else if (k === Inputmask.keyCode.INSERT && !(e.shiftKey || e.ctrlKey)) { //insert
					opts.insertMode = !opts.insertMode;
					caret(input, !opts.insertMode && pos.begin === getMaskLength() ? pos.begin - 1 : pos.begin);
				} else if (opts.tabThrough === true && k === Inputmask.keyCode.TAB) {
					if (e.shiftKey === true) {
						if (getTest(pos.begin).fn === null) {
							pos.begin = seekNext(pos.begin);
						}
						pos.end = seekPrevious(pos.begin, true);
						pos.begin = seekPrevious(pos.end, true);
					} else {
						pos.begin = seekNext(pos.begin, true);
						pos.end = seekNext(pos.begin, true);
						if (pos.end < getMaskLength()) pos.end--;
					}
					if (pos.begin < getMaskLength()) {
						e.preventDefault();
						caret(input, pos.begin, pos.end);
					}
				} else if (opts.insertMode === false && !e.shiftKey) {
					if (k === Inputmask.keyCode.RIGHT) {
						setTimeout(function() {
							var caretPos = caret(input);
							caret(input, caretPos.begin);
						}, 0);
					} else if (k === Inputmask.keyCode.LEFT) {
						setTimeout(function() {
							var caretPos = caret(input);
							caret(input, isRTL ? caretPos.begin + 1 : caretPos.begin - 1);
						}, 0);
					}
				}
				opts.onKeyDown.call(this, e, getBuffer(), caret(input).begin, opts);
				ignorable = $.inArray(k, opts.ignorables) !== -1;
			}

			function keypressEvent(e, checkval, writeOut, strict, ndx) {
				var input = this,
					$input = $(input),
					k = e.which || e.charCode || e.keyCode;

				if (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {
					if (k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join("")) {
						undoValue = getBuffer().join("");
						// e.preventDefault();
						setTimeout(function() {
							$input.trigger("change");
						}, 0);
					}
					return true;
				} else {
					if (k) {
						//special treat the decimal separator
						if (k === 46 && e.shiftKey === false && opts.radixPoint === ",") k = 44;
						var pos = checkval ? {
								begin: ndx,
								end: ndx
							} : caret(input),
							forwardPosition, c = String.fromCharCode(k);

						//should we clear a possible selection??
						var isSlctn = isSelection(pos.begin, pos.end);
						if (isSlctn) {
							getMaskSet().undoPositions = $.extend(true, {}, getMaskSet().validPositions); //init undobuffer for recovery when not valid
							handleRemove(input, Inputmask.keyCode.DELETE, pos, true);
							pos.begin = getMaskSet().p;
							if (!opts.insertMode) { //preserve some space
								opts.insertMode = !opts.insertMode;
								setValidPosition(pos.begin, strict);
								opts.insertMode = !opts.insertMode;
							}
							isSlctn = !opts.multi;
						}

						getMaskSet().writeOutBuffer = true;
						var p = isRTL && !isSlctn ? pos.end : pos.begin;
						var valResult = isValid(p, c, strict);
						if (valResult !== false) {
							if (valResult !== true) {
								p = valResult.pos !== undefined ? valResult.pos : p; //set new position from isValid
								c = valResult.c !== undefined ? valResult.c : c; //set new char from isValid
							}
							resetMaskSet(true);
							if (valResult.caret !== undefined) {
								forwardPosition = valResult.caret;
							} else {
								var vps = getMaskSet().validPositions;
								if (!opts.keepStatic && (vps[p + 1] !== undefined && getTests(p + 1, vps[p].locator.slice(), p).length > 1 || vps[p].alternation !== undefined)) {
									forwardPosition = p + 1;
								} else forwardPosition = seekNext(p);
							}
							getMaskSet().p = forwardPosition; //needed for checkval
						}

						if (writeOut !== false) {
							var self = this;
							setTimeout(function() {
								opts.onKeyValidation.call(self, k, valResult, opts);
							}, 0);
							if (getMaskSet().writeOutBuffer && valResult !== false) {
								var buffer = getBuffer();
								writeBuffer(input, buffer, checkval ? undefined : opts.numericInput ? seekPrevious(forwardPosition) : forwardPosition, e, checkval !== true);
								if (checkval !== true) {
									setTimeout(function() { //timeout needed for IE
										if (isComplete(buffer) === true) $input.trigger("complete");
									}, 0);
								}
							} else if (isSlctn) {
								getMaskSet().buffer = undefined;
								getMaskSet().validPositions = getMaskSet().undoPositions;
							}
						} else if (isSlctn) {
							getMaskSet().buffer = undefined;
							getMaskSet().validPositions = getMaskSet().undoPositions;
						}

						if (opts.showTooltip) { //update tooltip
							input.title = opts.tooltip || getMaskSet().mask;
						}

						if (checkval && $.isFunction(opts.onBeforeWrite)) {
							var result = opts.onBeforeWrite(e, getBuffer(), forwardPosition, opts);
							if (result && result.refreshFromBuffer) {
								var refresh = result.refreshFromBuffer;
								refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, result.buffer);
								resetMaskSet(true);
								if (result.caret) {
									getMaskSet().p = result.caret;
								}
							}
						}
						e.preventDefault();

						if (checkval) {
							return valResult;
						}
					}
				}
			}

			function pasteEvent(e) {
				var input = this,
					ev = e.originalEvent || e,
					$input = $(input),
					inputValue = input.inputmask._valueGet(true),
					caretPos = caret(input);
				//paste event for IE8 and lower I guess ;-)
				if (e.type === "propertychange" && input.inputmask._valueGet().length <= getMaskLength()) {
					return true;
				} else if (e.type === "paste") {
					var valueBeforeCaret = inputValue.substr(0, caretPos.begin),
						valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);

					if (valueBeforeCaret === getBufferTemplate().slice(0, caretPos.begin).join("")) valueBeforeCaret = "";
					if (valueAfterCaret === getBufferTemplate().slice(caretPos.end).join("")) valueAfterCaret = "";

					if (window.clipboardData && window.clipboardData.getData) { // IE
						inputValue = valueBeforeCaret + window.clipboardData.getData("Text") + valueAfterCaret;
					} else if (ev.clipboardData && ev.clipboardData.getData) {
						inputValue = valueBeforeCaret + ev.clipboardData.getData("text/plain") + valueAfterCaret;
					}
				}

				var pasteValue = inputValue;
				if ($.isFunction(opts.onBeforePaste)) {
					pasteValue = opts.onBeforePaste(inputValue, opts);
					if (pasteValue === false) {
						e.preventDefault();
						return false;
					}
					if (!pasteValue) {
						pasteValue = inputValue;
					}
				}
				checkVal(input, false, false, isRTL ? pasteValue.split("").reverse() : pasteValue.toString().split(""));
				writeBuffer(input, getBuffer(), undefined, e, true);
				$input.trigger("click");
				if (isComplete(getBuffer()) === true) {
					$input.trigger("complete");
				}

				return false;
			}

			function inputFallBackEvent(e) { //fallback when keypress & compositionevents fail
				var input = this,
					inputValue = input.inputmask._valueGet();
				if (getBuffer().join('') !== inputValue) {
					checkVal(input, true, false, inputValue.split(""));

					if (isComplete(getBuffer()) === true) {
						$(input).trigger("complete");
					}
					e.preventDefault();
				}
			}

			function mobileInputEvent(e) {
				var input = this;

				//backspace in chrome32 only fires input event - detect & treat
				var caretPos = caret(input),
					currentValue = input.inputmask._valueGet();

				currentValue = currentValue.replace(new RegExp("(" + Inputmask.escapeRegex(getBufferTemplate().join("")) + ")*"), "");
				//correct caretposition for chrome
				if (caretPos.begin > currentValue.length) {
					caret(input, currentValue.length);
					caretPos = caret(input);
				}
				if ((getBuffer().length - currentValue.length) === 1 && currentValue.charAt(caretPos.begin) !== getBuffer()[caretPos.begin] && currentValue.charAt(caretPos.begin + 1) !== getBuffer()[caretPos.begin] && !isMask(caretPos.begin)) {
					e.keyCode = opts.keyCode.BACKSPACE;
					keydownEvent.call(input, e);
				} else {
					inputFallBackEvent.call(this, e);
				}
				e.preventDefault();
			}

			function compositionStartEvent(e) {
				var ev = e.originalEvent || e;
				undoValue = getBuffer().join("");
				if (compositionData === "" || ev.data.indexOf(compositionData) !== 0) {
					// compositionCaretPos = caret(input);
				}
			}

			function compositionUpdateEvent(e) {
				var input = this,
					ev = e.originalEvent || e;
				if (ev.data.indexOf(compositionData) === 0) {
					resetMaskSet();
					getMaskSet().p = seekNext(-1); //needs check
					skipInputEvent = true;
				}
				var newData = ev.data;
				for (var i = 0; i < newData.length; i++) {
					var keypress = new $.Event("keypress");
					keypress.which = newData.charCodeAt(i);
					skipKeyPressEvent = false;
					ignorable = false;
					keypressEvent.call(input, keypress, true, false, false, getMaskSet().p); //needs check
				}
				setTimeout(function() {
					var forwardPosition = getMaskSet().p;
					writeBuffer(input, getBuffer(), opts.numericInput ? seekPrevious(forwardPosition) : forwardPosition);
				}, 0);
				compositionData = ev.data;
			}

			function compositionEndEvent(e) {
				//pickup by inputfallback
			}

			function setValueEvent(e) {
				var input = this,
					value = input.inputmask._valueGet();
				checkVal(input, true, false, ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask(value, opts) || value) : value).split(""));
				undoValue = getBuffer().join("");
				if ((opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join("")) {
					input.inputmask._valueSet("");
				}
			}

			function focusEvent(e) {
				var input = this,
					nptValue = input.inputmask._valueGet();
				if (opts.showMaskOnFocus && (!opts.showMaskOnHover || (opts.showMaskOnHover && nptValue === ""))) {
					if (input.inputmask._valueGet() !== getBuffer().join("")) {
						writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()));
					}
				} else if (mouseEnter === false) { //only executed on focus without mouseenter
					caret(input, seekNext(getLastValidPosition()));
				}
				if (opts.positionCaretOnTab === true) {
					setTimeout(function() {
						caret(input, seekNext(getLastValidPosition()));
					}, 0);
				}
				undoValue = getBuffer().join("");
			}

			function mouseleaveEvent(e) {
				var input = this;
				mouseEnter = false;
				if (opts.clearMaskOnLostFocus) {
					var buffer = getBuffer().slice(),
						nptValue = input.inputmask._valueGet();
					if (document.activeElement !== input && nptValue !== input.getAttribute("placeholder") && nptValue !== "") {
						if (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join("")) {
							buffer = [];
						} else { //clearout optional tail of the mask
							clearOptionalTail(buffer);
						}
						writeBuffer(input, buffer);
					}
				}
			}

			function clickEvent(e) {
				function doRadixFocus(clickPos) {
					if (opts.radixFocus && opts.radixPoint !== "") {
						var vps = getMaskSet().validPositions;
						if (vps[clickPos] === undefined || (vps[clickPos].input === getPlaceholder(clickPos))) {
							if (clickPos < seekNext(-1)) return true;
							var radixPos = $.inArray(opts.radixPoint, getBuffer());
							if (radixPos !== -1) {
								for (var vp in vps) {
									if (radixPos < vp && vps[vp].input !== getPlaceholder(vp)) {
										return false;
									}
								}
								return true;
							}
						}
					}
					return false;
				}
				var input = this;
				if (document.activeElement === input) {
					var selectedCaret = caret(input);
					if (selectedCaret.begin === selectedCaret.end) {
						if (doRadixFocus(selectedCaret.begin)) {
							caret(input, $.inArray(opts.radixPoint, getBuffer()));
						} else {
							var clickPosition = selectedCaret.begin,
								lvclickPosition = getLastValidPosition(clickPosition),
								lastPosition = seekNext(lvclickPosition);

							if (clickPosition < lastPosition) {
								caret(input, !isMask(clickPosition) && !isMask(clickPosition - 1) ? seekNext(clickPosition) : clickPosition);
							} else {
								if (getBuffer()[lastPosition] !== getPlaceholder(lastPosition) || (!isMask(lastPosition, true) && getTest(lastPosition).def === getPlaceholder(lastPosition))) {
									lastPosition = seekNext(lastPosition);
								}
								caret(input, lastPosition);
							}
						}
					}
				}
			}

			function dblclickEvent(e) {
				var input = this;
				setTimeout(function() {
					caret(input, 0, seekNext(getLastValidPosition()));
				}, 0);
			}

			function cutEvent(e) {
				var input = this,
					$input = $(input),
					pos = caret(input),
					ev = e.originalEvent || e;

				//correct clipboardData
				var clipboardData = window.clipboardData || ev.clipboardData,
					clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);
				clipboardData.setData("text", isRTL ? clipData.reverse().join("") : clipData.join(""));
				if (document.execCommand) document.execCommand("copy"); // copy selected content to system clipbaord

				handleRemove(input, Inputmask.keyCode.DELETE, pos);
				writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join(""));

				if (input.inputmask._valueGet() === getBufferTemplate().join("")) {
					$input.trigger("cleared");
				}

				if (opts.showTooltip) { //update tooltip
					input.title = opts.tooltip || getMaskSet().mask;
				}
			}

			function blurEvent(e) {
				var $input = $(this),
					input = this;
				if (input.inputmask) {
					var nptValue = input.inputmask._valueGet(),
						buffer = getBuffer().slice();
					if (undoValue !== buffer.join("")) {
						setTimeout(function() { //change event should be triggered after the other buffer manipulations on blur
							$input.trigger("change");
							undoValue = buffer.join("");
						}, 0);
					}
					if (nptValue !== "") {
						if (opts.clearMaskOnLostFocus) {
							if (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join("")) {
								buffer = [];
							} else { //clearout optional tail of the mask
								clearOptionalTail(buffer);
							}
						}
						if (isComplete(buffer) === false) {
							setTimeout(function() {
								$input.trigger("incomplete");
							}, 0);
							if (opts.clearIncomplete) {
								resetMaskSet();
								if (opts.clearMaskOnLostFocus) {
									buffer = [];
								} else {
									buffer = getBufferTemplate().slice();
								}
							}
						}

						writeBuffer(input, buffer, undefined, e);
					}
				}
			}

			function mouseenterEvent(e) {
				var input = this;
				mouseEnter = true;
				if (document.activeElement !== input && opts.showMaskOnHover) {
					if (input.inputmask._valueGet() !== getBuffer().join("")) {
						writeBuffer(input, getBuffer());
					}
				}
			}

			function submitEvent(e) { //trigger change on submit if any
				if (undoValue !== getBuffer().join("")) {
					$el.trigger("change");
				}
				if (opts.clearMaskOnLostFocus && getLastValidPosition() === -1 && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join("")) {
					el.inputmask._valueSet(""); //clear masktemplete on submit and still has focus
				}
				if (opts.removeMaskOnSubmit) {
					el.inputmask._valueSet(el.inputmask.unmaskedvalue(), true);
					setTimeout(function() {
						writeBuffer(el, getBuffer());
					}, 0);
				}
			}

			function resetEvent(e) {
				setTimeout(function() {
					$el.trigger("setvalue");
				}, 0);
			}

			function mask(elem) {
				el = elem;
				$el = $(el);

				//show tooltip
				if (opts.showTooltip) {
					el.title = opts.tooltip || getMaskSet().mask;
				}

				if (el.dir === "rtl" || opts.rightAlign) {
					el.style.textAlign = "right";
				}

				if (el.dir === "rtl" || opts.numericInput) {
					el.dir = "ltr";
					el.removeAttribute("dir");
					el.inputmask.isRTL = true;
					isRTL = true;
				}

				//unbind all events - to make sure that no other mask will interfere when re-masking
				EventRuler.off(el);
				patchValueProperty(el);
				if (isElementTypeSupported(el, opts)) {
					//bind events
					EventRuler.on(el, "submit", submitEvent);
					EventRuler.on(el, "reset", submitEvent);

					EventRuler.on(el, "mouseenter", mouseenterEvent);
					EventRuler.on(el, "blur", blurEvent);
					EventRuler.on(el, "focus", focusEvent);
					EventRuler.on(el, "mouseleave", mouseleaveEvent);
					EventRuler.on(el, "click", clickEvent);
					EventRuler.on(el, "dblclick", dblclickEvent);
					EventRuler.on(el, PasteEventType, pasteEvent);
					EventRuler.on(el, "dragdrop", pasteEvent);
					EventRuler.on(el, "drop", pasteEvent);
					EventRuler.on(el, "cut", cutEvent);
					EventRuler.on(el, "complete", opts.oncomplete);
					EventRuler.on(el, "incomplete", opts.onincomplete);
					EventRuler.on(el, "cleared", opts.oncleared);
					EventRuler.on(el, "keydown", keydownEvent);
					EventRuler.on(el, "keypress", keypressEvent);


					if (!androidfirefox) {
						EventRuler.on(el, "compositionstart", compositionStartEvent);
						EventRuler.on(el, "compositionupdate", compositionUpdateEvent);
						EventRuler.on(el, "compositionend", compositionEndEvent);
					}

					if (PasteEventType === "paste") {
						EventRuler.on(el, "input", inputFallBackEvent);
					}
					if (android || androidfirefox || androidchrome || kindle) {
						EventRuler.off(el, "input");
						EventRuler.on(el, "input", mobileInputEvent);
					}
				}
				EventRuler.on(el, "setvalue", setValueEvent);

				//apply mask
				if (el.inputmask._valueGet() !== "" || opts.clearMaskOnLostFocus === false) {
					var initialValue = $.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask(el.inputmask._valueGet(), opts) || el.inputmask._valueGet()) : el.inputmask._valueGet();
					checkVal(el, true, false, initialValue.split(""));
					var buffer = getBuffer().slice();
					undoValue = buffer.join("");
					// Wrap document.activeElement in a try/catch block since IE9 throw "Unspecified error" if document.activeElement is undefined when we are in an IFrame.
					if (isComplete(buffer) === false) {
						if (opts.clearIncomplete) {
							resetMaskSet();
						}
					}
					if (opts.clearMaskOnLostFocus) {
						if (buffer.join("") === getBufferTemplate().join("")) {
							buffer = [];
						} else {
							clearOptionalTail(buffer);
						}
					}
					writeBuffer(el, buffer);
					if (document.activeElement === el) { //position the caret when in focus
						caret(el, seekNext(getLastValidPosition()));
					}
				}
			}

			//action object
			var valueBuffer;
			if (actionObj !== undefined) {
				switch (actionObj.action) {
					case "isComplete":
						el = actionObj.el;
						return isComplete(getBuffer());
					case "unmaskedvalue":
						el = actionObj.el;

						if (el !== undefined && el.inputmask !== undefined) {
							maskset = el.inputmask.maskset;
							opts = el.inputmask.opts;
							isRTL = el.inputmask.isRTL;
						} else {
							valueBuffer = actionObj.value;

							if (opts.numericInput) {
								isRTL = true;
							}

							valueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask(valueBuffer, opts) || valueBuffer) : valueBuffer).split("");
							checkVal(undefined, false, false, isRTL ? valueBuffer.reverse() : valueBuffer);
							if ($.isFunction(opts.onBeforeWrite)) opts.onBeforeWrite(undefined, getBuffer(), 0, opts);
						}
						return unmaskedvalue(el);
					case "mask":
						el = actionObj.el;
						maskset = el.inputmask.maskset;
						opts = el.inputmask.opts;
						isRTL = el.inputmask.isRTL;
						undoValue = getBuffer().join("");
						mask(el);
						break;
					case "format":
						if (opts.numericInput) {
							isRTL = true;
						}
						valueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask(actionObj.value, opts) || actionObj.value) : actionObj.value).split("");
						checkVal(undefined, false, false, isRTL ? valueBuffer.reverse() : valueBuffer);
						if ($.isFunction(opts.onBeforeWrite)) opts.onBeforeWrite(undefined, getBuffer(), 0, opts);

						if (actionObj.metadata) {
							return {
								value: isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join(""),
								metadata: maskScope({
									"action": "getmetadata"
								}, maskset, opts)
							};
						}

						return isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join("");
					case "isValid":
						if (opts.numericInput) {
							isRTL = true;
						}
						if (actionObj.value) {
							valueBuffer = actionObj.value.split("");
							checkVal(undefined, false, true, isRTL ? valueBuffer.reverse() : valueBuffer);
						} else {
							actionObj.value = getBuffer().join("");
						}
						var buffer = getBuffer();
						var rl = determineLastRequiredPosition(),
							lmib = buffer.length - 1;
						for (; lmib > rl; lmib--) {
							if (isMask(lmib)) break;
						}
						buffer.splice(rl, lmib + 1 - rl);

						return isComplete(buffer) && actionObj.value === getBuffer().join("");
					case "getemptymask":
						return getBufferTemplate();
					case "remove":
						el = actionObj.el;
						$el = $(el);
						maskset = el.inputmask.maskset;
						opts = el.inputmask.opts;
						//writeout the unmaskedvalue
						el.inputmask._valueSet(unmaskedvalue(el));
						//unbind all events
						EventRuler.off(el);
						//restore the value property
						var valueProperty;
						if (Object.getOwnPropertyDescriptor) {
							valueProperty = Object.getOwnPropertyDescriptor(el, "value");
						}
						if (valueProperty && valueProperty.get) {
							if (el.inputmask.__valueGet) {
								Object.defineProperty(el, "value", {
									get: el.inputmask.__valueGet,
									set: el.inputmask.__valueSet
								});
							}
						} else if (document.__lookupGetter__ && el.__lookupGetter__("value")) {
							if (el.inputmask.__valueGet) {
								el.__defineGetter__("value", el.inputmask.__valueGet);
								el.__defineSetter__("value", el.inputmask.__valueSet);
							}
						}
						//clear data
						el.inputmask = undefined;
						break;
					case "getmetadata":
						if ($.isArray(maskset.metadata)) {
							//find last alternation
							var alternation, lvp = getLastValidPosition();
							for (var firstAlt = lvp; firstAlt >= 0; firstAlt--) {
								if (getMaskSet().validPositions[firstAlt] && getMaskSet().validPositions[firstAlt].alternation !== undefined) {
									alternation = getMaskSet().validPositions[firstAlt].alternation;
									break;
								}
							}
							if (alternation !== undefined) {
								return maskset.metadata[getMaskSet().validPositions[lvp].locator[alternation]];
							} else return maskset.metadata[0];
						}

						return maskset.metadata;
				}
			}
		}

		//make inputmask available
		window.Inputmask = Inputmask;
		return Inputmask;
	}));
</script>
  <script>/*
Input Mask plugin extensions
http://github.com/RobinHerbots/jquery.inputmask
Copyright (c) 2010 -  Robin Herbots
Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
Version: 0.0.0-dev

Optional extensions on the jquery.inputmask base
*/
(function(factory) {
		if (typeof define === "function" && define.amd) {
			define(["inputmask.dependencyLib", "inputmask"], factory);
		} else if (typeof exports === "object") {
			module.exports = factory(require("./inputmask.dependencyLib.jquery"), require("./inputmask"));
		} else {
			factory(window.dependencyLib || jQuery, window.Inputmask);
		}
	}
	(function($, Inputmask) {
		//extra definitions
		Inputmask.extendDefinitions({
			"A": {
				validator: "[A-Za-z\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5]",
				cardinality: 1,
				casing: "upper" //auto uppercasing
			},
			"&": { //alfanumeric uppercasing
				validator: "[0-9A-Za-z\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5]",
				cardinality: 1,
				casing: "upper"
			},
			"#": { //hexadecimal
				validator: "[0-9A-Fa-f]",
				cardinality: 1,
				casing: "upper"
			}
		});
		Inputmask.extendAliases({
			"url": {
				definitions: {
					"i": {
						validator: ".",
						cardinality: 1
					}
				},
				mask: "(\\http://)|(\\http\\s://)|(ftp://)|(ftp\\s://)i{+}",
				insertMode: false,
				autoUnmask: false
			},
			"ip": { //ip-address mask
				mask: "i[i[i]].i[i[i]].i[i[i]].i[i[i]]",
				definitions: {
					"i": {
						validator: function(chrs, maskset, pos, strict, opts) {
							if (pos - 1 > -1 && maskset.buffer[pos - 1] !== ".") {
								chrs = maskset.buffer[pos - 1] + chrs;
								if (pos - 2 > -1 && maskset.buffer[pos - 2] !== ".") {
									chrs = maskset.buffer[pos - 2] + chrs;
								} else chrs = "0" + chrs;
							} else chrs = "00" + chrs;
							return new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]").test(chrs);
						},
						cardinality: 1
					}
				},
				onUnMask: function(maskedValue, unmaskedValue, opts) {
					return maskedValue;
				}
			},
			"email": {
				mask: "*{1,64}[.*{1,64}][.*{1,64}][.*{1,64}]@*{1,64}[.*{2,64}][.*{2,6}][.*{1,2}]",
				greedy: false,
				onBeforePaste: function(pastedValue, opts) {
					pastedValue = pastedValue.toLowerCase();
					return pastedValue.replace("mailto:", "");
				},
				definitions: {
					"*": {
						validator: "[0-9A-Za-z!#$%&'*+/=?^_`{|}~\-]",
						cardinality: 1,
						casing: "lower"
					}
				},
				onUnMask: function(maskedValue, unmaskedValue, opts) {
					return maskedValue;
				}
			},
			"mac": {
				mask: "##:##:##:##:##:##"
			}
		});
		return Inputmask;
	}));
</script>
  <script>/*
Input Mask plugin extensions
http://github.com/RobinHerbots/jquery.inputmask
Copyright (c) 2010 -  Robin Herbots
Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
Version: 0.0.0-dev

Optional extensions on the jquery.inputmask base
*/
(function(factory) {
		if (typeof define === "function" && define.amd) {
			define(["inputmask.dependencyLib", "inputmask"], factory);
		} else if (typeof exports === "object") {
			module.exports = factory(require("./inputmask.dependencyLib.jquery"), require("./inputmask"));
		} else {
			factory(window.dependencyLib || jQuery, window.Inputmask);
		}
	}
	(function($, Inputmask) {
		//number aliases
		Inputmask.extendAliases({
			"numeric": {
				mask: function(opts) {
					function autoEscape(txt) {
						var escapedTxt = "";
						for (var i = 0; i < txt.length; i++) {
							escapedTxt += opts.definitions[txt.charAt(i)] ? "\\" + txt.charAt(i) : txt.charAt(i);
						}
						return escapedTxt;
					}
					if (opts.repeat !== 0 && isNaN(opts.integerDigits)) {
						opts.integerDigits = opts.repeat;
					}
					opts.repeat = 0;
					if (opts.groupSeparator === opts.radixPoint) { //treat equal separator and radixpoint
						if (opts.radixPoint === ".") {
							opts.groupSeparator = ",";
						} else if (opts.radixPoint === ",") {
							opts.groupSeparator = ".";
						} else opts.groupSeparator = "";
					}
					if (opts.groupSeparator === " ") { //prevent conflict with default skipOptionalPartCharacter
						opts.skipOptionalPartCharacter = undefined;
					}
					opts.autoGroup = opts.autoGroup && opts.groupSeparator !== "";
					if (opts.autoGroup) {
						if (typeof opts.groupSize == "string" && isFinite(opts.groupSize)) opts.groupSize = parseInt(opts.groupSize);
						if (isFinite(opts.integerDigits)) {
							var seps = Math.floor(opts.integerDigits / opts.groupSize);
							var mod = opts.integerDigits % opts.groupSize;
							opts.integerDigits = parseInt(opts.integerDigits) + (mod === 0 ? seps - 1 : seps);
							if (opts.integerDigits < 1) {
								opts.integerDigits = "*";
							}
						}
					}

					//enforce placeholder to single
					if (opts.placeholder.length > 1) {
						opts.placeholder = opts.placeholder.charAt(0);
					}
					//only allow radixfocus when placeholder = 0
					opts.radixFocus = opts.radixFocus && opts.placeholder !== "" && opts.integerOptional === true;

					opts.definitions[";"] = opts.definitions["~"]; //clone integer def for decimals
					opts.definitions[";"].definitionSymbol = "~";

					if (opts.numericInput === true) { //finance people input style
						opts.radixFocus = false;
						opts.digitsOptional = false;
						if (isNaN(opts.digits)) opts.digits = 2;
						opts.decimalProtect = false;
					}

					var mask = autoEscape(opts.prefix);
					mask += "[+]";
					if (opts.integerOptional === true) {
						mask += "~{1," + opts.integerDigits + "}";
					} else mask += "~{" + opts.integerDigits + "}";
					if (opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) {
						if (opts.digitsOptional) {
							mask += "[" + (opts.decimalProtect ? ":" : opts.radixPoint) + ";{1," + opts.digits + "}]";
						} else mask += (opts.decimalProtect ? ":" : opts.radixPoint) + ";{" + opts.digits + "}";
					}
					if (opts.negationSymbol.back !== "") {
						mask += "[-]";
					}
					mask += autoEscape(opts.suffix);

					opts.greedy = false; //enforce greedy false

					return mask;
				},
				placeholder: "",
				greedy: false,
				digits: "*", //number of fractionalDigits
				digitsOptional: true,
				radixPoint: ".",
				radixFocus: true,
				groupSize: 3,
				groupSeparator: "",
				autoGroup: false,
				allowPlus: true,
				allowMinus: true,
				negationSymbol: {
					front: "-", //"("
					back: "" //")"
				},
				integerDigits: "+", //number of integerDigits
				integerOptional: true,
				prefix: "",
				suffix: "",
				rightAlign: true,
				decimalProtect: true, //do not allow assumption of decimals input without entering the radixpoint
				min: null, //minimum value
				max: null, //maximum value
				step: 1,
				insertMode: true,
				autoUnmask: false,
				unmaskAsNumber: false,
				postFormat: function(buffer, pos, reformatOnly, opts) { //this needs to be removed // this is crap
					// console.log(buffer);
					if (opts.numericInput === true) {
						buffer = buffer.reverse();
						if (isFinite(pos)) {
							pos = buffer.join("").length - pos - 1;
						}
					}
					var suffixStripped = false,
						i, l;
					if (buffer.length >= opts.suffix.length && buffer.join("").indexOf(opts.suffix) === (buffer.length - opts.suffix.length)) {
						buffer.length = buffer.length - opts.suffix.length; //strip suffix
						suffixStripped = true;
					}
					//position overflow corrections
					pos = pos >= buffer.length ? buffer.length - 1 : (pos < opts.prefix.length ? opts.prefix.length : pos);

					var needsRefresh = false,
						charAtPos = buffer[pos];
					if (opts.groupSeparator === "" || (opts.numericInput !== true &&
							($.inArray(opts.radixPoint, buffer) !== -1 && pos > $.inArray(opts.radixPoint, buffer)) ||
							new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "\+]").test(charAtPos))) {
						if (suffixStripped) {
							for (i = 0, l = opts.suffix.length; i < l; i++) {
								buffer.push(opts.suffix.charAt(i));
							}
						}
						//console.log("return input " + buffer);
						return {
							pos: pos
						};
					}

					var cbuf = buffer.slice();
					if (charAtPos === opts.groupSeparator) {
						cbuf.splice(pos--, 1);
						charAtPos = cbuf[pos];
					}
					if (reformatOnly) {
						if (charAtPos !== opts.radixPoint) cbuf[pos] = "?";
					} else cbuf.splice(pos, 0, "?"); //set position indicator
					var bufVal = cbuf.join(""),
						bufValOrigin = bufVal;
					if (bufVal.length > 0 && opts.autoGroup || (reformatOnly && bufVal.indexOf(opts.groupSeparator) !== -1)) {
						var escapedGroupSeparator = Inputmask.escapeRegex(opts.groupSeparator);
						needsRefresh = bufVal.indexOf(opts.groupSeparator) === 0;
						bufVal = bufVal.replace(new RegExp(escapedGroupSeparator, "g"), "");
						var radixSplit = bufVal.split(opts.radixPoint);
						bufVal = opts.radixPoint === "" ? bufVal : radixSplit[0];
						if (bufVal !== (opts.prefix + "?0") && bufVal.length >= (opts.groupSize + opts.prefix.length)) {
							//needsRefresh = true;
							var reg = new RegExp("([-\+]?[\\d\?]+)([\\d\?]{" + opts.groupSize + "})");
							while (reg.test(bufVal)) {
								bufVal = bufVal.replace(reg, "$1" + opts.groupSeparator + "$2");
								bufVal = bufVal.replace(opts.groupSeparator + opts.groupSeparator, opts.groupSeparator);
							}
						}
						if (opts.radixPoint !== "" && radixSplit.length > 1) {
							bufVal += opts.radixPoint + radixSplit[1];
						}
					}
					needsRefresh = bufValOrigin !== bufVal;
					buffer.length = bufVal.length; //align the length
					for (i = 0, l = bufVal.length; i < l; i++) {
						buffer[i] = bufVal.charAt(i);
					}
					var newPos = $.inArray("?", buffer);
					if (newPos === -1 && charAtPos === opts.radixPoint) newPos = $.inArray(opts.radixPoint, buffer);
					if (reformatOnly) buffer[newPos] = charAtPos;
					else buffer.splice(newPos, 1);

					if (!needsRefresh && suffixStripped) {
						for (i = 0, l = opts.suffix.length; i < l; i++) {
							buffer.push(opts.suffix.charAt(i));
						}
					}
					// console.log("formatted " + buffer + " refresh " + needsRefresh);
					newPos = (opts.numericInput && isFinite(pos)) ? buffer.join("").length - newPos - 1 : newPos;
					if (opts.numericInput) {
						buffer = buffer.reverse();
						if ($.inArray(opts.radixPoint, buffer) < newPos && (buffer.join("").length - opts.suffix.length) !== newPos) {
							newPos = newPos - 1;
						}
					}
					return {
						pos: newPos,
						"refreshFromBuffer": needsRefresh,
						"buffer": buffer
					};
				},
				onBeforeWrite: function(e, buffer, caretPos, opts) {
					if (e && (e.type === "blur" || e.type === "checkval")) {
						//handle minvalue
						var maskedValue = buffer.join(""),
							processValue = maskedValue.replace(opts.prefix, "");
						processValue = processValue.replace(opts.suffix, "");
						processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), "");
						if (opts.radixPoint === ",") processValue = processValue.replace(Inputmask.escapeRegex(opts.radixPoint), ".");

						if (isFinite(processValue)) {
							if (isFinite(opts.min) && parseFloat(processValue) < parseFloat(opts.min)) {
								return $.extend(true, {
									"refreshFromBuffer": true,
									"buffer": (opts.prefix + opts.min).split("")
								}, opts.postFormat((opts.prefix + opts.min).split(""), 0, true, opts));
							}
						}
						if (opts.numericInput !== true) {
							var tmpBufSplit = opts.radixPoint !== "" ? buffer.join("").split(opts.radixPoint) : [buffer.join("")],
								matchRslt = tmpBufSplit[0].match(opts.regex.integerPart(opts)),
								matchRsltDigits = tmpBufSplit.length === 2 ? tmpBufSplit[1].match(opts.regex.integerNPart(opts)) : undefined;
							if (matchRslt) {
								if ((matchRslt[0] === opts.negationSymbol.front + "0" || matchRslt[0] === opts.negationSymbol.front || matchRslt[0] === "+") && (matchRsltDigits === undefined || matchRsltDigits[0].match(/^0+$/))) {
									buffer.splice(matchRslt.index, 1);
								}
								var radixPosition = $.inArray(opts.radixPoint, buffer);
								if (radixPosition !== -1) {
									if (isFinite(opts.digits) && !opts.digitsOptional) {
										for (var i = 1; i <= opts.digits; i++) {
											if (buffer[radixPosition + i] === undefined || buffer[radixPosition + i] === opts.placeholder.charAt(0)) {
												buffer[radixPosition + i] = "0";
											}
										}
										return {
											"refreshFromBuffer": maskedValue !== buffer.join(""),
											"buffer": buffer
										};
									} else if (radixPosition === buffer.length - opts.suffix.length - 1) {
										buffer.splice(radixPosition, 1);
										return {
											"refreshFromBuffer": true,
											"buffer": buffer
										};
									}
								}
							}
						}
					}

					if (opts.autoGroup) {
						var rslt = opts.postFormat(buffer, opts.numericInput ? caretPos : caretPos - 1, true, opts);
						rslt.caret = caretPos <= opts.prefix.length ? rslt.pos : rslt.pos + 1;
						return rslt;
					}
				},
				regex: {
					integerPart: function(opts) {
						return new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "\+]?\\d+");
					},
					integerNPart: function(opts) {
						return new RegExp("[\\d" + Inputmask.escapeRegex(opts.groupSeparator) + "]+");
					}
				},
				signHandler: function(chrs, maskset, pos, strict, opts) {
					if (!strict && (opts.allowMinus && chrs === "-") || (opts.allowPlus && chrs === "+")) {
						var matchRslt = maskset.buffer.join("").match(opts.regex.integerPart(opts));

						if (matchRslt && matchRslt[0].length > 0) {
							if (maskset.buffer[matchRslt.index] === (chrs === "-" ? "+" : opts.negationSymbol.front)) {
								if (chrs === "-") {
									if (opts.negationSymbol.back !== "") {
										return {
											"pos": matchRslt.index,
											"c": opts.negationSymbol.front,
											"remove": matchRslt.index,
											"caret": pos,
											"insert": {
												"pos": maskset.buffer.length - opts.suffix.length - 1,
												"c": opts.negationSymbol.back
											}
										};
									} else {
										return {
											"pos": matchRslt.index,
											"c": opts.negationSymbol.front,
											"remove": matchRslt.index,
											"caret": pos
										};
									}
								} else {
									if (opts.negationSymbol.back !== "") {
										return {
											"pos": matchRslt.index,
											"c": "+",
											"remove": [matchRslt.index, maskset.buffer.length - opts.suffix.length - 1],
											"caret": pos
										};
									} else {
										return {
											"pos": matchRslt.index,
											"c": "+",
											"remove": matchRslt.index,
											"caret": pos
										};
									}
								}
							} else if (maskset.buffer[matchRslt.index] === (chrs === "-" ? opts.negationSymbol.front : "+")) {
								if (chrs === "-" && opts.negationSymbol.back !== "") {
									return {
										"remove": [matchRslt.index, maskset.buffer.length - opts.suffix.length - 1],
										"caret": pos - 1
									};
								} else {
									return {
										"remove": matchRslt.index,
										"caret": pos - 1
									};
								}
							} else {
								if (chrs === "-") {
									if (opts.negationSymbol.back !== "") {
										return {
											"pos": matchRslt.index,
											"c": opts.negationSymbol.front,
											"caret": pos + 1,
											"insert": {
												"pos": maskset.buffer.length - opts.suffix.length,
												"c": opts.negationSymbol.back
											}
										};
									} else {
										return {
											"pos": matchRslt.index,
											"c": opts.negationSymbol.front,
											"caret": pos + 1
										};
									}
								} else {
									return {
										"pos": matchRslt.index,
										"c": chrs,
										"caret": pos + 1
									};
								}
							}
						}
					}
					return false;
				},
				radixHandler: function(chrs, maskset, pos, strict, opts) {
					if (!strict) {
						if ($.inArray(chrs, [",", "."]) !== -1) chrs = opts.radixPoint;
						if (chrs === opts.radixPoint && (opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0))) {
							var radixPos = $.inArray(opts.radixPoint, maskset.buffer),
								integerValue = maskset.buffer.join("").match(opts.regex.integerPart(opts));

							if (radixPos !== -1 && maskset.validPositions[radixPos]) {
								if (maskset.validPositions[radixPos - 1]) {
									return {
										"caret": radixPos + 1
									};
								} else {
									return {
										"pos": integerValue.index,
										c: integerValue[0],
										"caret": radixPos + 1
									};
								}
							} else if (!integerValue || (integerValue["0"] === "0" && (integerValue.index + 1) !== pos)) {
								maskset.buffer[integerValue ? integerValue.index : pos] = "0";
								return {
									"pos": (integerValue ? integerValue.index : pos) + 1,
									c: opts.radixPoint
								};
							}
						}
					}
					return false;
				},
				leadingZeroHandler: function(chrs, maskset, pos, strict, opts) {
					if (opts.numericInput === true) {
						if (maskset.buffer[maskset.buffer.length - opts.prefix.length - 1] === "0") {
							return {
								"pos": pos,
								"remove": maskset.buffer.length - opts.prefix.length - 1
							};
						}
					} else {
						var matchRslt = maskset.buffer.join("").match(opts.regex.integerNPart(opts)),
							radixPosition = $.inArray(opts.radixPoint, maskset.buffer);
						if (matchRslt && !strict && (radixPosition === -1 || pos <= radixPosition)) {
							if (matchRslt["0"].indexOf("0") === 0) {
								if (pos < opts.prefix.length) pos = matchRslt.index; //position
								var _radixPosition = $.inArray(opts.radixPoint, maskset._buffer);
								var digitsMatch = maskset._buffer && maskset.buffer.slice(radixPosition).join("") === maskset._buffer.slice(_radixPosition).join("") || parseInt(maskset.buffer.slice(radixPosition + 1).join("")) === 0;
								var integerMatch = maskset._buffer && maskset.buffer.slice(matchRslt.index, radixPosition).join("") === maskset._buffer.slice(opts.prefix.length, _radixPosition).join("") || maskset.buffer.slice(matchRslt.index, radixPosition).join("") === "0";

								if (radixPosition === -1 || digitsMatch && integerMatch) {
									maskset.buffer.splice(matchRslt.index, 1);
									pos = pos > matchRslt.index ? pos - 1 : matchRslt.index;
									return {
										"pos": pos,
										"remove": matchRslt.index
									};
								} else if (matchRslt.index + 1 === pos || chrs === "0") {
									maskset.buffer.splice(matchRslt.index, 1);
									pos = matchRslt.index;
									return {
										"pos": pos,
										"remove": matchRslt.index
									};
								}
							} else if (chrs === "0" && pos <= matchRslt.index && matchRslt["0"] !== opts.groupSeparator) {
								return false;
							}
						}
					}
					return true;
				},
				postValidation: function(buffer, opts) {
					//handle maxvalue
					var isValid = true,
						maskedValue = buffer.join(""),
						processValue = maskedValue.replace(opts.prefix, "");
					processValue = processValue.replace(opts.suffix, "");
					processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), "");
					if (opts.radixPoint === ",") processValue = processValue.replace(Inputmask.escapeRegex(opts.radixPoint), ".");
					//handle negation symbol
					processValue = processValue.replace(new RegExp("^" + Inputmask.escapeRegex(opts.negationSymbol.front)), "-");
					processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), "");
					processValue = processValue === opts.negationSymbol.front ? processValue + "0" : processValue;

					if (isFinite(processValue)) {
						if (opts.max !== null && isFinite(opts.max)) {
							isValid = parseFloat(processValue) <= parseFloat(opts.max);
						}
						if (isValid && opts.min !== null && isFinite(opts.min) && (processValue <= 0 || processValue.toString().length >= opts.min.toString().length)) {
							isValid = parseFloat(processValue) >= parseFloat(opts.min);
							if (!isValid) {
								isValid = $.extend(true, {
									"refreshFromBuffer": true,
									"buffer": (opts.prefix + opts.min).split("")
								}, opts.postFormat((opts.prefix + opts.min).split(""), 0, true, opts));
								isValid.refreshFromBuffer = true; //enforce refresh
							}
						}
					}

					return isValid;
				},
				definitions: {
					"~": {
						validator: function(chrs, maskset, pos, strict, opts) {
							var isValid = opts.signHandler(chrs, maskset, pos, strict, opts);
							if (!isValid) {
								isValid = opts.radixHandler(chrs, maskset, pos, strict, opts);
								if (!isValid) {
									isValid = strict ? new RegExp("[0-9" + Inputmask.escapeRegex(opts.groupSeparator) + "]").test(chrs) : new RegExp("[0-9]").test(chrs);
									if (isValid === true) {
										isValid = opts.leadingZeroHandler(chrs, maskset, pos, strict, opts);
										if (isValid === true) {
											//handle overwrite when fixed precision
											var radixPosition = $.inArray(opts.radixPoint, maskset.buffer);
											if (radixPosition !== -1 && opts.digitsOptional === false && opts.numericInput !== true && pos > radixPosition && !strict) {
												isValid = {
													"pos": pos,
													"remove": pos
												};
											} else {
												isValid = {
													pos: pos
												};
											}
										}
									}
								}
							}

							return isValid;
						},
						cardinality: 1,
						prevalidator: null
					},
					"+": {
						validator: function(chrs, maskset, pos, strict, opts) {
							var isValid = opts.signHandler(chrs, maskset, pos, strict, opts);
							if (!isValid && ((strict && opts.allowMinus && chrs === opts.negationSymbol.front) || (opts.allowMinus && chrs === "-") || (opts.allowPlus && chrs === "+"))) {
								if (chrs === "-") {
									if (opts.negationSymbol.back !== "") {
										isValid = {
											"pos": pos,
											"c": chrs === "-" ? opts.negationSymbol.front : "+",
											"caret": pos + 1,
											"insert": {
												"pos": maskset.buffer.length,
												"c": opts.negationSymbol.back
											}
										};
									} else {
										isValid = {
											"pos": pos,
											"c": chrs === "-" ? opts.negationSymbol.front : "+",
											"caret": pos + 1
										};
									}
								} else {
									isValid = true;
								}
							}
							return isValid;
						},
						cardinality: 1,
						prevalidator: null,
						placeholder: ""
					},
					"-": {
						validator: function(chrs, maskset, pos, strict, opts) {
							var isValid = opts.signHandler(chrs, maskset, pos, strict, opts);
							if (!isValid && strict && opts.allowMinus && chrs === opts.negationSymbol.back) {
								isValid = true;
							}
							return isValid;
						},
						cardinality: 1,
						prevalidator: null,
						placeholder: ""
					},
					":": {
						validator: function(chrs, maskset, pos, strict, opts) {
							var isValid = opts.signHandler(chrs, maskset, pos, strict, opts);
							if (!isValid) {
								var radix = "[" + Inputmask.escapeRegex(opts.radixPoint) + ",\\." + "]";
								isValid = new RegExp(radix).test(chrs);
								if (isValid && maskset.validPositions[pos] && maskset.validPositions[pos].match.placeholder === opts.radixPoint) {
									isValid = {
										"caret": pos + 1
									};
								}
							}
							return isValid ? {
								c: opts.radixPoint
							} : isValid;
						},
						cardinality: 1,
						prevalidator: null,
						placeholder: function(opts) {
							return opts.radixPoint;
						}
					}
				},
				onUnMask: function(maskedValue, unmaskedValue, opts) {
					var processValue = maskedValue.replace(opts.prefix, "");
					processValue = processValue.replace(opts.suffix, "");
					processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), "");
					if (opts.unmaskAsNumber) {
						if (opts.radixPoint !== "" && processValue.indexOf(opts.radixPoint) !== -1) processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), ".");
						return Number(processValue);
					}
					return processValue;
				},
				isComplete: function(buffer, opts) {
					var maskedValue = buffer.join(""),
						bufClone = buffer.slice();
					//verify separator positions
					opts.postFormat(bufClone, 0, true, opts);
					if (bufClone.join("") !== maskedValue) return false;

					var processValue = maskedValue.replace(opts.prefix, "");
					processValue = processValue.replace(opts.suffix, "");
					processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), "");
					if (opts.radixPoint === ",") processValue = processValue.replace(Inputmask.escapeRegex(opts.radixPoint), ".");
					return isFinite(processValue);
				},
				onBeforeMask: function(initialValue, opts) {
					if (opts.radixPoint !== "" && isFinite(initialValue)) {
						initialValue = initialValue.toString().replace(".", opts.radixPoint);
					} else {
						var kommaMatches = initialValue.match(/,/g);
						var dotMatches = initialValue.match(/\./g);
						if (dotMatches && kommaMatches) {
							if (dotMatches.length > kommaMatches.length) {
								initialValue = initialValue.replace(/\./g, "");
								initialValue = initialValue.replace(",", opts.radixPoint);
							} else if (kommaMatches.length > dotMatches.length) {
								initialValue = initialValue.replace(/,/g, "");
								initialValue = initialValue.replace(".", opts.radixPoint);
							} else { //equal
								initialValue = initialValue.indexOf(".") < initialValue.indexOf(",") ? initialValue.replace(/\./g, "") : initialValue = initialValue.replace(/,/g, "");
							}
						} else {
							initialValue = initialValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), "");
						}
					}

					if (opts.digits === 0) {
						if (initialValue.indexOf(".") !== -1) {
							initialValue = initialValue.substring(0, initialValue.indexOf("."));
						} else if (initialValue.indexOf(",") !== -1) {
							initialValue = initialValue.substring(0, initialValue.indexOf(","));
						}
					}

					if (opts.radixPoint !== "" && isFinite(opts.digits) && initialValue.indexOf(opts.radixPoint) !== -1) {
						var valueParts = initialValue.split(opts.radixPoint),
							decPart = valueParts[1].match(new RegExp("\\d*"))[0];
						if (parseInt(opts.digits) < decPart.toString().length) {
							var digitsFactor = Math.pow(10, parseInt(opts.digits));
							//make the initialValue a valid javascript number for the parsefloat
							initialValue = initialValue.replace(Inputmask.escapeRegex(opts.radixPoint), ".");
							initialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor;
							initialValue = initialValue.toString().replace(".", opts.radixPoint);
						}
					}
					return initialValue.toString();
				},
				canClearPosition: function(maskset, position, lvp, strict, opts) {
					var positionInput = maskset.validPositions[position].input,
						canClear = ((positionInput !== opts.radixPoint || (maskset.validPositions[position].match.fn !== null && opts.decimalProtect === false)) || isFinite(positionInput)) ||
						position === lvp ||
						positionInput === opts.groupSeparator ||
						positionInput === opts.negationSymbol.front ||
						positionInput === opts.negationSymbol.back;

					if (canClear && isFinite(positionInput)) {
						var matchRslt,
							radixPos = $.inArray(opts.radixPoint, maskset.buffer);

						//inject radixpoint
						var radixInjection = false;
						if (maskset.validPositions[radixPos] === undefined) {
							maskset.validPositions[radixPos] = {
								input: opts.radixPoint
							};
							radixInjection = true;
						}

						if (!strict && maskset.buffer) {
							matchRslt = maskset.buffer.join("").substr(0, position).match(opts.regex.integerNPart(opts));
							var pos = position + 1,
								isNull = matchRslt == null || parseInt(matchRslt["0"].replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), "")) === 0;
							if (isNull) {
								while (maskset.validPositions[pos] && (maskset.validPositions[pos].input === opts.groupSeparator || maskset.validPositions[pos].input === "0")) {
									delete maskset.validPositions[pos];
									pos++;
								}
							}
						}

						var buffer = [];
						//build new buffer from validPositions
						for (var vp in maskset.validPositions) {
							if (maskset.validPositions[vp].input !== undefined) buffer.push(maskset.validPositions[vp].input);
						}
						//remove radix Injection
						if (radixInjection) {
							delete maskset.validPositions[radixPos];
						}

						if (radixPos > 0) {
							var bufVal = buffer.join("");
							matchRslt = bufVal.match(opts.regex.integerNPart(opts));
							if (matchRslt) {
								if (position <= radixPos) {
									if (matchRslt["0"].indexOf("0") === 0) {
										canClear = matchRslt.index !== position || opts.placeholder === "0";
									} else {
										var intPart = parseInt(matchRslt["0"].replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), "")),
											radixPart = parseInt(bufVal.split(opts.radixPoint)[1]);
										if (intPart < 10 && maskset.validPositions[position] && (opts.placeholder !== "0" || radixPart > 0)) {
											maskset.validPositions[position].input = "0";
											maskset.p = opts.prefix.length + 1;
											canClear = false;
										}
									}
								} else if (matchRslt["0"].indexOf("0") === 0) {
									if (bufVal.length === 3) {
										maskset.validPositions = {};
										canClear = false;
									}
								}
							}
						}
					}

					return canClear;
				},
				onKeyDown: function(e, buffer, caretPos, opts) {
					var $input = $(this);
					if (e.ctrlKey) {
						switch (e.keyCode) {
							case Inputmask.keyCode.UP:
								$input.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step));
								$input.trigger("setvalue");
								break;
							case Inputmask.keyCode.DOWN:
								$input.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step));
								$input.trigger("setvalue");
								break;
						}
					}
				}
			},
			"currency": {
				prefix: "$ ",
				groupSeparator: ",",
				alias: "numeric",
				placeholder: "0",
				autoGroup: true,
				digits: 2,
				digitsOptional: false,
				clearMaskOnLostFocus: false
			},
			"decimal": {
				alias: "numeric"
			},
			"integer": {
				alias: "numeric",
				digits: 0,
				radixPoint: ""
			},
			"percentage": {
				alias: "numeric",
				digits: 2,
				radixPoint: ".",
				placeholder: "0",
				autoGroup: false,
				min: 0,
				max: 100,
				suffix: " %",
				allowPlus: false,
				allowMinus: false
			}
		});
		return Inputmask;
	}));
</script>
  <script>/*
Input Mask plugin extensions
http://github.com/RobinHerbots/jquery.inputmask
Copyright (c) 2010 -  Robin Herbots
Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
Version: 0.0.0-dev

Regex extensions on the jquery.inputmask base
Allows for using regular expressions as a mask
*/
(function(factory) {
		if (typeof define === "function" && define.amd) {
			define(["inputmask.dependencyLib", "inputmask"], factory);
		} else if (typeof exports === "object") {
			module.exports = factory(require("./inputmask.dependencyLib.jquery"), require("./inputmask"));
		} else {
			factory(window.dependencyLib || jQuery, window.Inputmask);
		}
	}
	(function($, Inputmask) {
	Inputmask.extendAliases({ // $(selector).inputmask("Regex", { regex: "[0-9]*"}
		"Regex": {
			mask: "r",
			greedy: false,
			repeat: "*",
			regex: null,
			regexTokens: null,
			//Thx to https://github.com/slevithan/regex-colorizer for the tokenizer regex
			tokenizer: /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
			quantifierFilter: /[0-9]+[^,]/,
			isComplete: function(buffer, opts) {
				return new RegExp(opts.regex).test(buffer.join(""));
			},
			definitions: {
				"r": {
					validator: function(chrs, maskset, pos, strict, opts) {
						var cbuffer = maskset.buffer.slice(),
							regexPart = "",
							isValid = false,
							openGroupCount = 0,
							groupToken;

						function RegexToken(isGroup, isQuantifier) {
							this.matches = [];
							this.isGroup = isGroup || false;
							this.isQuantifier = isQuantifier || false;
							this.quantifier = {
								min: 1,
								max: 1
							};
							this.repeaterPart = undefined;
						}

						function analyseRegex() {
							var currentToken = new RegexToken(),
								match, m, opengroups = [];

							opts.regexTokens = [];

							// The tokenizer regex does most of the tokenization grunt work
							while (match = opts.tokenizer.exec(opts.regex)) {
								m = match[0];
								switch (m.charAt(0)) {
									case "(": // Group opening
										opengroups.push(new RegexToken(true));
										break;
									case ")": // Group closing
										groupToken = opengroups.pop();
										if (opengroups.length > 0)
											opengroups[opengroups.length - 1].matches.push(groupToken);
										else
											currentToken.matches.push(groupToken);

										break;
									case "{":
									case "+":
									case "*": //Quantifier
										var quantifierToken = new RegexToken(false, true);
										m = m.replace(/[{}]/g, "");
										var mq = m.split(","),
											mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
											mq1 = mq.length === 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1]));
										quantifierToken.quantifier = {
											min: mq0,
											max: mq1
										};
										if (opengroups.length > 0) {
											var matches = opengroups[opengroups.length - 1].matches;
											match = matches.pop();
											if (!match.isGroup) {
												groupToken = new RegexToken(true);
												groupToken.matches.push(match);
												match = groupToken;
											}
											matches.push(match);
											matches.push(quantifierToken);
										} else {
											match = currentToken.matches.pop();
											if (!match.isGroup) {
												groupToken = new RegexToken(true);
												groupToken.matches.push(match);
												match = groupToken;
											}
											currentToken.matches.push(match);
											currentToken.matches.push(quantifierToken);
										}
										break;
									default:
										if (opengroups.length > 0) {
											opengroups[opengroups.length - 1].matches.push(m);
										} else {
											currentToken.matches.push(m);
										}
										break;
								}
							}

							if (currentToken.matches.length > 0)
								opts.regexTokens.push(currentToken);
						}

						function validateRegexToken(token, fromGroup) {
							var isvalid = false;
							if (fromGroup) {
								regexPart += "(";
								openGroupCount++;
							}
							for (var mndx = 0; mndx < token.matches.length; mndx++) {
								var matchToken = token.matches[mndx];
								if (matchToken.isGroup === true) {
									isvalid = validateRegexToken(matchToken, true);
								} else if (matchToken.isQuantifier === true) {
									var crrntndx = $.inArray(matchToken, token.matches),
										matchGroup = token.matches[crrntndx - 1];
									var regexPartBak = regexPart;
									if (isNaN(matchToken.quantifier.max)) {
										while (matchToken.repeaterPart && matchToken.repeaterPart !== regexPart && matchToken.repeaterPart.length > regexPart.length) {
											isvalid = validateRegexToken(matchGroup, true);
											if (isvalid) break;
										}
										isvalid = isvalid || validateRegexToken(matchGroup, true);
										if (isvalid) matchToken.repeaterPart = regexPart;
										regexPart = regexPartBak + matchToken.quantifier.max;
									} else {
										for (var i = 0, qm = matchToken.quantifier.max - 1; i < qm; i++) {
											isvalid = validateRegexToken(matchGroup, true);
											if (isvalid) break;
										}
										regexPart = regexPartBak + "{" + matchToken.quantifier.min + "," + matchToken.quantifier.max + "}";
									}
								} else if (matchToken.matches !== undefined) {
									for (var k = 0; k < matchToken.length; k++) {
										isvalid = validateRegexToken(matchToken[k], fromGroup);
										if (isvalid) break;
									}
								} else {
									var testExp;
									if (matchToken.charAt(0) == "[") {
										testExp = regexPart;
										testExp += matchToken;
										for (var j = 0; j < openGroupCount; j++) {
											testExp += ")";
										}
										var exp = new RegExp("^(" + testExp + ")$");
										isvalid = exp.test(bufferStr);
									} else {
										for (var l = 0, tl = matchToken.length; l < tl; l++) {
											if (matchToken.charAt(l) === "\\") continue;
											testExp = regexPart;
											testExp += matchToken.substr(0, l + 1);
											testExp = testExp.replace(/\|$/, "");
											for (var j = 0; j < openGroupCount; j++) {
												testExp += ")";
											}
											var exp = new RegExp("^(" + testExp + ")$");
											isvalid = exp.test(bufferStr);
											if (isvalid) break;
										}
									}
									regexPart += matchToken;
								}
								if (isvalid) break;
							}

							if (fromGroup) {
								regexPart += ")";
								openGroupCount--;
							}

							return isvalid;
						}

						if (opts.regexTokens === null)
							analyseRegex();


						cbuffer.splice(pos, 0, chrs);
						var bufferStr = cbuffer.join("");
						for (var i = 0; i < opts.regexTokens.length; i++) {
							var regexToken = opts.regexTokens[i];
							isValid = validateRegexToken(regexToken, regexToken.isGroup);
							if (isValid) break;
						}

						return isValid;
					},
					cardinality: 1
				}
			}
		}
	});
	return Inputmask;
}));
</script>
  <script>/*
Input Mask plugin extensions
http://github.com/RobinHerbots/jquery.inputmask
Copyright (c) 2010 -  Robin Herbots
Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
Version: 0.0.0-dev

Phone extension.
When using this extension make sure you specify the correct url to get the masks

 $(selector).inputmask("phone", {
                url: "Scripts/jquery.inputmask/phone-codes/phone-codes.json",
                onKeyValidation: function () { //show some metadata in the console
                    console.log($(this).inputmask("getmetadata")["cd"]);
                }
  });


*/
(function(factory) {
		if (typeof define === "function" && define.amd) {
			define(["jquery", "inputmask"], factory);
		} else if (typeof exports === "object") {
			module.exports = factory(require("jquery"), require("./inputmask"));
		} else {
			factory(window.dependencyLib || jQuery, window.Inputmask);
		}
	}
	(function($, Inputmask) {
		Inputmask.extendAliases({
			"phone": {
				url: "phone-codes/phone-codes.js",
				countrycode: "",
				mask: function(opts) {
					opts.definitions["#"] = opts.definitions["9"];
					var maskList = [];
					$.ajax({
						url: opts.url,
						async: false,
						dataType: "json",
						success: function(response) {
							maskList = response;
						},
						error: function(xhr, ajaxOptions, thrownError) {
							alert(thrownError + " - " + opts.url);
						}
					});

					maskList = maskList.sort(function(a, b) {
						return (a.mask || a) < (b.mask || b) ? -1 : 1;
					});

					return maskList;
				},
				keepStatic: false,
				nojumps: true,
				nojumpsThreshold: 1,
				onBeforeMask: function(value, opts) {
					var processedValue = value.replace(/^0/g, "");
					if (processedValue.indexOf(opts.countrycode) > 1 || processedValue.indexOf(opts.countrycode) === -1) {
						processedValue = "+" + opts.countrycode + processedValue;
					}

					return processedValue;
				}
			},
			"phonebe": {
				alias: "phone",
				url: "phone-codes/phone-be.js",
				countrycode: "32",
				nojumpsThreshold: 4
			}
		});
		return Inputmask;
	}));
</script>
  <script>/*
 * Input Mask plugin for jquery
 * http://github.com/RobinHerbots/jquery.inputmask
 * Copyright (c) 2010 -	Robin Herbots
 * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
 * Version: 0.0.0-dev
 */

(function(factory) {
		if (typeof define === "function" && define.amd) {
			define(["jquery", "inputmask"], factory);
		} else if (typeof exports === "object") {
			module.exports = factory(require("jquery"), require("./inputmask"));
		} else {
			factory(jQuery, window.Inputmask);
		}
	}
	(function($, Inputmask) {
		if ($.fn.inputmask === undefined) {
			//jquery plugin
			$.fn.inputmask = function(fn, options) {
				var nptmask, input = this[0];
				options = options || {};
				if (typeof fn === "string") {
					switch (fn) {
						case "unmaskedvalue":
							return input && input.inputmask ? input.inputmask.unmaskedvalue() : $(input).val();
						case "remove":
							return this.each(function() {
								if (this.inputmask) this.inputmask.remove();
							});
						case "getemptymask":
							return input && input.inputmask ? input.inputmask.getemptymask() : "";
						case "hasMaskedValue": //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value
							return input && input.inputmask ? input.inputmask.hasMaskedValue() : false;
						case "isComplete":
							return input && input.inputmask ? input.inputmask.isComplete() : true;
						case "getmetadata": //return mask metadata if exists
							return input && input.inputmask ? input.inputmask.getmetadata() : undefined;
						case "setvalue":
							$(input).val(options);
							if (input && input.inputmask !== undefined) {
								$(input).triggerHandler("setvalue");
							}
							break;
						case "option":
							if (typeof options === "string") {
								if (input && input.inputmask !== undefined) {
									return input.inputmask.option(options);
								}
							} else {
								return this.each(function() {
									if (this.inputmask !== undefined) {
										return this.inputmask.option(options);
									}
								});
							}
							break;
						default:
							options.alias = fn;
							nptmask = new Inputmask(options);
							return this.each(function() {
								nptmask.mask(this);
							});
					}
				} else if (typeof fn == "object") {
					nptmask = new Inputmask(fn);
					if (fn.mask === undefined && fn.alias === undefined) {
						return this.each(function() {
							if (this.inputmask !== undefined) {
								return this.inputmask.option(fn);
							} else nptmask.mask(this);
						});
					} else {
						return this.each(function() {
							nptmask.mask(this);
						});
					}
				} else if (fn === undefined) {
					//look for data-inputmask atributes
					return this.each(function() {
						nptmask = new Inputmask(options);
						nptmask.mask(this);
					});
				}
			};
		}
		return $.fn.inputmask;
	}));
</script>
  <script>/*! iCheck v1.0.2 by Damir Sultanov, http://git.io/arlzeA, MIT Licensed */
(function(f){function A(a,b,d){var c=a[0],g=/er/.test(d)?_indeterminate:/bl/.test(d)?n:k,e=d==_update?{checked:c[k],disabled:c[n],indeterminate:"true"==a.attr(_indeterminate)||"false"==a.attr(_determinate)}:c[g];if(/^(ch|di|in)/.test(d)&&!e)x(a,g);else if(/^(un|en|de)/.test(d)&&e)q(a,g);else if(d==_update)for(var f in e)e[f]?x(a,f,!0):q(a,f,!0);else if(!b||"toggle"==d){if(!b)a[_callback]("ifClicked");e?c[_type]!==r&&q(a,g):x(a,g)}}function x(a,b,d){var c=a[0],g=a.parent(),e=b==k,u=b==_indeterminate,
    v=b==n,s=u?_determinate:e?y:"enabled",F=l(a,s+t(c[_type])),B=l(a,b+t(c[_type]));if(!0!==c[b]){if(!d&&b==k&&c[_type]==r&&c.name){var w=a.closest("form"),p='input[name="'+c.name+'"]',p=w.length?w.find(p):f(p);p.each(function(){this!==c&&f(this).data(m)&&q(f(this),b)})}u?(c[b]=!0,c[k]&&q(a,k,"force")):(d||(c[b]=!0),e&&c[_indeterminate]&&q(a,_indeterminate,!1));D(a,e,b,d)}c[n]&&l(a,_cursor,!0)&&g.find("."+C).css(_cursor,"default");g[_add](B||l(a,b)||"");g.attr("role")&&!u&&g.attr("aria-"+(v?n:k),"true");
    g[_remove](F||l(a,s)||"")}function q(a,b,d){var c=a[0],g=a.parent(),e=b==k,f=b==_indeterminate,m=b==n,s=f?_determinate:e?y:"enabled",q=l(a,s+t(c[_type])),r=l(a,b+t(c[_type]));if(!1!==c[b]){if(f||!d||"force"==d)c[b]=!1;D(a,e,s,d)}!c[n]&&l(a,_cursor,!0)&&g.find("."+C).css(_cursor,"pointer");g[_remove](r||l(a,b)||"");g.attr("role")&&!f&&g.attr("aria-"+(m?n:k),"false");g[_add](q||l(a,s)||"")}function E(a,b){if(a.data(m)){a.parent().html(a.attr("style",a.data(m).s||""));if(b)a[_callback](b);a.off(".i").unwrap();
    f(_label+'[for="'+a[0].id+'"]').add(a.closest(_label)).off(".i")}}function l(a,b,f){if(a.data(m))return a.data(m).o[b+(f?"":"Class")]}function t(a){return a.charAt(0).toUpperCase()+a.slice(1)}function D(a,b,f,c){if(!c){if(b)a[_callback]("ifToggled");a[_callback]("ifChanged")[_callback]("if"+t(f))}}var m="iCheck",C=m+"-helper",r="radio",k="checked",y="un"+k,n="disabled";_determinate="determinate";_indeterminate="in"+_determinate;_update="update";_type="type";_click="click";_touch="touchbegin.i touchend.i";
    _add="addClass";_remove="removeClass";_callback="trigger";_label="label";_cursor="cursor";_mobile=/ipad|iphone|ipod|android|blackberry|windows phone|opera mini|silk/i.test(navigator.userAgent);f.fn[m]=function(a,b){var d='input[type="checkbox"], input[type="'+r+'"]',c=f(),g=function(a){a.each(function(){var a=f(this);c=a.is(d)?c.add(a):c.add(a.find(d))})};if(/^(check|uncheck|toggle|indeterminate|determinate|disable|enable|update|destroy)$/i.test(a))return a=a.toLowerCase(),g(this),c.each(function(){var c=
        f(this);"destroy"==a?E(c,"ifDestroyed"):A(c,!0,a);f.isFunction(b)&&b()});if("object"!=typeof a&&a)return this;var e=f.extend({checkedClass:k,disabledClass:n,indeterminateClass:_indeterminate,labelHover:!0},a),l=e.handle,v=e.hoverClass||"hover",s=e.focusClass||"focus",t=e.activeClass||"active",B=!!e.labelHover,w=e.labelHoverClass||"hover",p=(""+e.increaseArea).replace("%","")|0;if("checkbox"==l||l==r)d='input[type="'+l+'"]';-50>p&&(p=-50);g(this);return c.each(function(){var a=f(this);E(a);var c=this,
        b=c.id,g=-p+"%",d=100+2*p+"%",d={position:"absolute",top:g,left:g,display:"block",width:d,height:d,margin:0,padding:0,background:"#fff",border:0,opacity:0},g=_mobile?{position:"absolute",visibility:"hidden"}:p?d:{position:"absolute",opacity:0},l="checkbox"==c[_type]?e.checkboxClass||"icheckbox":e.radioClass||"i"+r,z=f(_label+'[for="'+b+'"]').add(a.closest(_label)),u=!!e.aria,y=m+"-"+Math.random().toString(36).substr(2,6),h='<div class="'+l+'" '+(u?'role="'+c[_type]+'" ':"");u&&z.each(function(){h+=
        'aria-labelledby="';this.id?h+=this.id:(this.id=y,h+=y);h+='"'});h=a.wrap(h+"/>")[_callback]("ifCreated").parent().append(e.insert);d=f('<ins class="'+C+'"/>').css(d).appendTo(h);a.data(m,{o:e,s:a.attr("style")}).css(g);e.inheritClass&&h[_add](c.className||"");e.inheritID&&b&&h.attr("id",m+"-"+b);"static"==h.css("position")&&h.css("position","relative");A(a,!0,_update);if(z.length)z.on(_click+".i mouseover.i mouseout.i "+_touch,function(b){var d=b[_type],e=f(this);if(!c[n]){if(d==_click){if(f(b.target).is("a"))return;
        A(a,!1,!0)}else B&&(/ut|nd/.test(d)?(h[_remove](v),e[_remove](w)):(h[_add](v),e[_add](w)));if(_mobile)b.stopPropagation();else return!1}});a.on(_click+".i focus.i blur.i keyup.i keydown.i keypress.i",function(b){var d=b[_type];b=b.keyCode;if(d==_click)return!1;if("keydown"==d&&32==b)return c[_type]==r&&c[k]||(c[k]?q(a,k):x(a,k)),!1;if("keyup"==d&&c[_type]==r)!c[k]&&x(a,k);else if(/us|ur/.test(d))h["blur"==d?_remove:_add](s)});d.on(_click+" mousedown mouseup mouseover mouseout "+_touch,function(b){var d=
        b[_type],e=/wn|up/.test(d)?t:v;if(!c[n]){if(d==_click)A(a,!1,!0);else{if(/wn|er|in/.test(d))h[_add](e);else h[_remove](e+" "+t);if(z.length&&B&&e==v)z[/ut|nd/.test(d)?_remove:_add](w)}if(_mobile)b.stopPropagation();else return!1}})})}})(window.jQuery||window.Zepto);</script>
  <script>/*! jQuery Validation Plugin - v1.13.0 - 7/1/2014
 * http://jqueryvalidation.org/
 * Copyright (c) 2014 JÃ¶rn Zaefferer; Licensed MIT */
!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):a(jQuery)}(function(a){a.extend(a.fn,{validate:function(b){if(!this.length)return void(b&&b.debug&&window.console&&console.warn("Nothing selected, can't validate, returning nothing."));var c=a.data(this[0],"validator");return c?c:(this.attr("novalidate","novalidate"),c=new a.validator(b,this[0]),a.data(this[0],"validator",c),c.settings.onsubmit&&(this.validateDelegate(":submit","click",function(b){c.settings.submitHandler&&(c.submitButton=b.target),a(b.target).hasClass("cancel")&&(c.cancelSubmit=!0),void 0!==a(b.target).attr("formnovalidate")&&(c.cancelSubmit=!0)}),this.submit(function(b){function d(){var d;return c.settings.submitHandler?(c.submitButton&&(d=a("<input type='hidden'/>").attr("name",c.submitButton.name).val(a(c.submitButton).val()).appendTo(c.currentForm)),c.settings.submitHandler.call(c,c.currentForm,b),c.submitButton&&d.remove(),!1):!0}return c.settings.debug&&b.preventDefault(),c.cancelSubmit?(c.cancelSubmit=!1,d()):c.form()?c.pendingRequest?(c.formSubmitted=!0,!1):d():(c.focusInvalid(),!1)})),c)},valid:function(){var b,c;return a(this[0]).is("form")?b=this.validate().form():(b=!0,c=a(this[0].form).validate(),this.each(function(){b=c.element(this)&&b})),b},removeAttrs:function(b){var c={},d=this;return a.each(b.split(/\s/),function(a,b){c[b]=d.attr(b),d.removeAttr(b)}),c},rules:function(b,c){var d,e,f,g,h,i,j=this[0];if(b)switch(d=a.data(j.form,"validator").settings,e=d.rules,f=a.validator.staticRules(j),b){case"add":a.extend(f,a.validator.normalizeRule(c)),delete f.messages,e[j.name]=f,c.messages&&(d.messages[j.name]=a.extend(d.messages[j.name],c.messages));break;case"remove":return c?(i={},a.each(c.split(/\s/),function(b,c){i[c]=f[c],delete f[c],"required"===c&&a(j).removeAttr("aria-required")}),i):(delete e[j.name],f)}return g=a.validator.normalizeRules(a.extend({},a.validator.classRules(j),a.validator.attributeRules(j),a.validator.dataRules(j),a.validator.staticRules(j)),j),g.required&&(h=g.required,delete g.required,g=a.extend({required:h},g),a(j).attr("aria-required","true")),g.remote&&(h=g.remote,delete g.remote,g=a.extend(g,{remote:h})),g}}),a.extend(a.expr[":"],{blank:function(b){return!a.trim(""+a(b).val())},filled:function(b){return!!a.trim(""+a(b).val())},unchecked:function(b){return!a(b).prop("checked")}}),a.validator=function(b,c){this.settings=a.extend(!0,{},a.validator.defaults,b),this.currentForm=c,this.init()},a.validator.format=function(b,c){return 1===arguments.length?function(){var c=a.makeArray(arguments);return c.unshift(b),a.validator.format.apply(this,c)}:(arguments.length>2&&c.constructor!==Array&&(c=a.makeArray(arguments).slice(1)),c.constructor!==Array&&(c=[c]),a.each(c,function(a,c){b=b.replace(new RegExp("\\{"+a+"\\}","g"),function(){return c})}),b)},a.extend(a.validator,{defaults:{messages:{},groups:{},rules:{},errorClass:"error",validClass:"valid",errorElement:"label",focusInvalid:!0,errorContainer:a([]),errorLabelContainer:a([]),onsubmit:!0,ignore:":hidden",ignoreTitle:!1,onfocusin:function(a){this.lastActive=a,this.settings.focusCleanup&&!this.blockFocusCleanup&&(this.settings.unhighlight&&this.settings.unhighlight.call(this,a,this.settings.errorClass,this.settings.validClass),this.hideThese(this.errorsFor(a)))},onfocusout:function(a){this.checkable(a)||!(a.name in this.submitted)&&this.optional(a)||this.element(a)},onkeyup:function(a,b){(9!==b.which||""!==this.elementValue(a))&&(a.name in this.submitted||a===this.lastElement)&&this.element(a)},onclick:function(a){a.name in this.submitted?this.element(a):a.parentNode.name in this.submitted&&this.element(a.parentNode)},highlight:function(b,c,d){"radio"===b.type?this.findByName(b.name).addClass(c).removeClass(d):a(b).addClass(c).removeClass(d)},unhighlight:function(b,c,d){"radio"===b.type?this.findByName(b.name).removeClass(c).addClass(d):a(b).removeClass(c).addClass(d)}},setDefaults:function(b){a.extend(a.validator.defaults,b)},messages:{required:"This field is required.",remote:"Please fix this field.",email:"Please enter a valid email address.",url:"Please enter a valid URL.",date:"Please enter a valid date.",dateISO:"Please enter a valid date ( ISO ).",number:"Please enter a valid number.",digits:"Please enter only digits.",creditcard:"Please enter a valid credit card number.",equalTo:"Please enter the same value again.",maxlength:a.validator.format("Please enter no more than {0} characters."),minlength:a.validator.format("Please enter at least {0} characters."),rangelength:a.validator.format("Please enter a value between {0} and {1} characters long."),range:a.validator.format("Please enter a value between {0} and {1}."),max:a.validator.format("Please enter a value less than or equal to {0}."),min:a.validator.format("Please enter a value greater than or equal to {0}.")},autoCreateRanges:!1,prototype:{init:function(){function b(b){var c=a.data(this[0].form,"validator"),d="on"+b.type.replace(/^validate/,""),e=c.settings;e[d]&&!this.is(e.ignore)&&e[d].call(c,this[0],b)}this.labelContainer=a(this.settings.errorLabelContainer),this.errorContext=this.labelContainer.length&&this.labelContainer||a(this.currentForm),this.containers=a(this.settings.errorContainer).add(this.settings.errorLabelContainer),this.submitted={},this.valueCache={},this.pendingRequest=0,this.pending={},this.invalid={},this.reset();var c,d=this.groups={};a.each(this.settings.groups,function(b,c){"string"==typeof c&&(c=c.split(/\s/)),a.each(c,function(a,c){d[c]=b})}),c=this.settings.rules,a.each(c,function(b,d){c[b]=a.validator.normalizeRule(d)}),a(this.currentForm).validateDelegate(":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'] ,[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox']","focusin focusout keyup",b).validateDelegate("select, option, [type='radio'], [type='checkbox']","click",b),this.settings.invalidHandler&&a(this.currentForm).bind("invalid-form.validate",this.settings.invalidHandler),a(this.currentForm).find("[required], [data-rule-required], .required").attr("aria-required","true")},form:function(){return this.checkForm(),a.extend(this.submitted,this.errorMap),this.invalid=a.extend({},this.errorMap),this.valid()||a(this.currentForm).triggerHandler("invalid-form",[this]),this.showErrors(),this.valid()},checkForm:function(){this.prepareForm();for(var a=0,b=this.currentElements=this.elements();b[a];a++)this.check(b[a]);return this.valid()},element:function(b){var c=this.clean(b),d=this.validationTargetFor(c),e=!0;return this.lastElement=d,void 0===d?delete this.invalid[c.name]:(this.prepareElement(d),this.currentElements=a(d),e=this.check(d)!==!1,e?delete this.invalid[d.name]:this.invalid[d.name]=!0),a(b).attr("aria-invalid",!e),this.numberOfInvalids()||(this.toHide=this.toHide.add(this.containers)),this.showErrors(),e},showErrors:function(b){if(b){a.extend(this.errorMap,b),this.errorList=[];for(var c in b)this.errorList.push({message:b[c],element:this.findByName(c)[0]});this.successList=a.grep(this.successList,function(a){return!(a.name in b)})}this.settings.showErrors?this.settings.showErrors.call(this,this.errorMap,this.errorList):this.defaultShowErrors()},resetForm:function(){a.fn.resetForm&&a(this.currentForm).resetForm(),this.submitted={},this.lastElement=null,this.prepareForm(),this.hideErrors(),this.elements().removeClass(this.settings.errorClass).removeData("previousValue").removeAttr("aria-invalid")},numberOfInvalids:function(){return this.objectLength(this.invalid)},objectLength:function(a){var b,c=0;for(b in a)c++;return c},hideErrors:function(){this.hideThese(this.toHide)},hideThese:function(a){a.not(this.containers).text(""),this.addWrapper(a).hide()},valid:function(){return 0===this.size()},size:function(){return this.errorList.length},focusInvalid:function(){if(this.settings.focusInvalid)try{a(this.findLastActive()||this.errorList.length&&this.errorList[0].element||[]).filter(":visible").focus().trigger("focusin")}catch(b){}},findLastActive:function(){var b=this.lastActive;return b&&1===a.grep(this.errorList,function(a){return a.element.name===b.name}).length&&b},elements:function(){var b=this,c={};return a(this.currentForm).find("input, select, textarea").not(":submit, :reset, :image, [disabled]").not(this.settings.ignore).filter(function(){return!this.name&&b.settings.debug&&window.console&&console.error("%o has no name assigned",this),this.name in c||!b.objectLength(a(this).rules())?!1:(c[this.name]=!0,!0)})},clean:function(b){return a(b)[0]},errors:function(){var b=this.settings.errorClass.split(" ").join(".");return a(this.settings.errorElement+"."+b,this.errorContext)},reset:function(){this.successList=[],this.errorList=[],this.errorMap={},this.toShow=a([]),this.toHide=a([]),this.currentElements=a([])},prepareForm:function(){this.reset(),this.toHide=this.errors().add(this.containers)},prepareElement:function(a){this.reset(),this.toHide=this.errorsFor(a)},elementValue:function(b){var c,d=a(b),e=b.type;return"radio"===e||"checkbox"===e?a("input[name='"+b.name+"']:checked").val():"number"===e&&"undefined"!=typeof b.validity?b.validity.badInput?!1:d.val():(c=d.val(),"string"==typeof c?c.replace(/\r/g,""):c)},check:function(b){b=this.validationTargetFor(this.clean(b));var c,d,e,f=a(b).rules(),g=a.map(f,function(a,b){return b}).length,h=!1,i=this.elementValue(b);for(d in f){e={method:d,parameters:f[d]};try{if(c=a.validator.methods[d].call(this,i,b,e.parameters),"dependency-mismatch"===c&&1===g){h=!0;continue}if(h=!1,"pending"===c)return void(this.toHide=this.toHide.not(this.errorsFor(b)));if(!c)return this.formatAndAdd(b,e),!1}catch(j){throw this.settings.debug&&window.console&&console.log("Exception occurred when checking element "+b.id+", check the '"+e.method+"' method.",j),j}}if(!h)return this.objectLength(f)&&this.successList.push(b),!0},customDataMessage:function(b,c){return a(b).data("msg"+c.charAt(0).toUpperCase()+c.substring(1).toLowerCase())||a(b).data("msg")},customMessage:function(a,b){var c=this.settings.messages[a];return c&&(c.constructor===String?c:c[b])},findDefined:function(){for(var a=0;a<arguments.length;a++)if(void 0!==arguments[a])return arguments[a];return void 0},defaultMessage:function(b,c){return this.findDefined(this.customMessage(b.name,c),this.customDataMessage(b,c),!this.settings.ignoreTitle&&b.title||void 0,a.validator.messages[c],"<strong>Warning: No message defined for "+b.name+"</strong>")},formatAndAdd:function(b,c){var d=this.defaultMessage(b,c.method),e=/\$?\{(\d+)\}/g;"function"==typeof d?d=d.call(this,c.parameters,b):e.test(d)&&(d=a.validator.format(d.replace(e,"{$1}"),c.parameters)),this.errorList.push({message:d,element:b,method:c.method}),this.errorMap[b.name]=d,this.submitted[b.name]=d},addWrapper:function(a){return this.settings.wrapper&&(a=a.add(a.parent(this.settings.wrapper))),a},defaultShowErrors:function(){var a,b,c;for(a=0;this.errorList[a];a++)c=this.errorList[a],this.settings.highlight&&this.settings.highlight.call(this,c.element,this.settings.errorClass,this.settings.validClass),this.showLabel(c.element,c.message);if(this.errorList.length&&(this.toShow=this.toShow.add(this.containers)),this.settings.success)for(a=0;this.successList[a];a++)this.showLabel(this.successList[a]);if(this.settings.unhighlight)for(a=0,b=this.validElements();b[a];a++)this.settings.unhighlight.call(this,b[a],this.settings.errorClass,this.settings.validClass);this.toHide=this.toHide.not(this.toShow),this.hideErrors(),this.addWrapper(this.toShow).show()},validElements:function(){return this.currentElements.not(this.invalidElements())},invalidElements:function(){return a(this.errorList).map(function(){return this.element})},showLabel:function(b,c){var d,e,f,g=this.errorsFor(b),h=this.idOrName(b),i=a(b).attr("aria-describedby");g.length?(g.removeClass(this.settings.validClass).addClass(this.settings.errorClass),g.html(c)):(g=a("<"+this.settings.errorElement+">").attr("id",h+"-error").addClass(this.settings.errorClass).html(c||""),d=g,this.settings.wrapper&&(d=g.hide().show().wrap("<"+this.settings.wrapper+"/>").parent()),this.labelContainer.length?this.labelContainer.append(d):this.settings.errorPlacement?this.settings.errorPlacement(d,a(b)):d.insertAfter(b),g.is("label")?g.attr("for",h):0===g.parents("label[for='"+h+"']").length&&(f=g.attr("id"),i?i.match(new RegExp("\b"+f+"\b"))||(i+=" "+f):i=f,a(b).attr("aria-describedby",i),e=this.groups[b.name],e&&a.each(this.groups,function(b,c){c===e&&a("[name='"+b+"']",this.currentForm).attr("aria-describedby",g.attr("id"))}))),!c&&this.settings.success&&(g.text(""),"string"==typeof this.settings.success?g.addClass(this.settings.success):this.settings.success(g,b)),this.toShow=this.toShow.add(g)},errorsFor:function(b){var c=this.idOrName(b),d=a(b).attr("aria-describedby"),e="label[for='"+c+"'], label[for='"+c+"'] *";return d&&(e=e+", #"+d.replace(/\s+/g,", #")),this.errors().filter(e)},idOrName:function(a){return this.groups[a.name]||(this.checkable(a)?a.name:a.id||a.name)},validationTargetFor:function(a){return this.checkable(a)&&(a=this.findByName(a.name).not(this.settings.ignore)[0]),a},checkable:function(a){return/radio|checkbox/i.test(a.type)},findByName:function(b){return a(this.currentForm).find("[name='"+b+"']")},getLength:function(b,c){switch(c.nodeName.toLowerCase()){case"select":return a("option:selected",c).length;case"input":if(this.checkable(c))return this.findByName(c.name).filter(":checked").length}return b.length},depend:function(a,b){return this.dependTypes[typeof a]?this.dependTypes[typeof a](a,b):!0},dependTypes:{"boolean":function(a){return a},string:function(b,c){return!!a(b,c.form).length},"function":function(a,b){return a(b)}},optional:function(b){var c=this.elementValue(b);return!a.validator.methods.required.call(this,c,b)&&"dependency-mismatch"},startRequest:function(a){this.pending[a.name]||(this.pendingRequest++,this.pending[a.name]=!0)},stopRequest:function(b,c){this.pendingRequest--,this.pendingRequest<0&&(this.pendingRequest=0),delete this.pending[b.name],c&&0===this.pendingRequest&&this.formSubmitted&&this.form()?(a(this.currentForm).submit(),this.formSubmitted=!1):!c&&0===this.pendingRequest&&this.formSubmitted&&(a(this.currentForm).triggerHandler("invalid-form",[this]),this.formSubmitted=!1)},previousValue:function(b){return a.data(b,"previousValue")||a.data(b,"previousValue",{old:null,valid:!0,message:this.defaultMessage(b,"remote")})}},classRuleSettings:{required:{required:!0},email:{email:!0},url:{url:!0},date:{date:!0},dateISO:{dateISO:!0},number:{number:!0},digits:{digits:!0},creditcard:{creditcard:!0}},addClassRules:function(b,c){b.constructor===String?this.classRuleSettings[b]=c:a.extend(this.classRuleSettings,b)},classRules:function(b){var c={},d=a(b).attr("class");return d&&a.each(d.split(" "),function(){this in a.validator.classRuleSettings&&a.extend(c,a.validator.classRuleSettings[this])}),c},attributeRules:function(b){var c,d,e={},f=a(b),g=b.getAttribute("type");for(c in a.validator.methods)"required"===c?(d=b.getAttribute(c),""===d&&(d=!0),d=!!d):d=f.attr(c),/min|max/.test(c)&&(null===g||/number|range|text/.test(g))&&(d=Number(d)),d||0===d?e[c]=d:g===c&&"range"!==g&&(e[c]=!0);return e.maxlength&&/-1|2147483647|524288/.test(e.maxlength)&&delete e.maxlength,e},dataRules:function(b){var c,d,e={},f=a(b);for(c in a.validator.methods)d=f.data("rule"+c.charAt(0).toUpperCase()+c.substring(1).toLowerCase()),void 0!==d&&(e[c]=d);return e},staticRules:function(b){var c={},d=a.data(b.form,"validator");return d.settings.rules&&(c=a.validator.normalizeRule(d.settings.rules[b.name])||{}),c},normalizeRules:function(b,c){return a.each(b,function(d,e){if(e===!1)return void delete b[d];if(e.param||e.depends){var f=!0;switch(typeof e.depends){case"string":f=!!a(e.depends,c.form).length;break;case"function":f=e.depends.call(c,c)}f?b[d]=void 0!==e.param?e.param:!0:delete b[d]}}),a.each(b,function(d,e){b[d]=a.isFunction(e)?e(c):e}),a.each(["minlength","maxlength"],function(){b[this]&&(b[this]=Number(b[this]))}),a.each(["rangelength","range"],function(){var c;b[this]&&(a.isArray(b[this])?b[this]=[Number(b[this][0]),Number(b[this][1])]:"string"==typeof b[this]&&(c=b[this].replace(/[\[\]]/g,"").split(/[\s,]+/),b[this]=[Number(c[0]),Number(c[1])]))}),a.validator.autoCreateRanges&&(b.min&&b.max&&(b.range=[b.min,b.max],delete b.min,delete b.max),b.minlength&&b.maxlength&&(b.rangelength=[b.minlength,b.maxlength],delete b.minlength,delete b.maxlength)),b},normalizeRule:function(b){if("string"==typeof b){var c={};a.each(b.split(/\s/),function(){c[this]=!0}),b=c}return b},addMethod:function(b,c,d){a.validator.methods[b]=c,a.validator.messages[b]=void 0!==d?d:a.validator.messages[b],c.length<3&&a.validator.addClassRules(b,a.validator.normalizeRule(b))},methods:{required:function(b,c,d){if(!this.depend(d,c))return"dependency-mismatch";if("select"===c.nodeName.toLowerCase()){var e=a(c).val();return e&&e.length>0}return this.checkable(c)?this.getLength(b,c)>0:a.trim(b).length>0},email:function(a,b){return this.optional(b)||/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(a)},url:function(a,b){return this.optional(b)||/^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(a)},date:function(a,b){return this.optional(b)||!/Invalid|NaN/.test(new Date(a).toString())},dateISO:function(a,b){return this.optional(b)||/^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(a)},number:function(a,b){return this.optional(b)||/^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(a)},digits:function(a,b){return this.optional(b)||/^\d+$/.test(a)},creditcard:function(a,b){if(this.optional(b))return"dependency-mismatch";if(/[^0-9 \-]+/.test(a))return!1;var c,d,e=0,f=0,g=!1;if(a=a.replace(/\D/g,""),a.length<13||a.length>19)return!1;for(c=a.length-1;c>=0;c--)d=a.charAt(c),f=parseInt(d,10),g&&(f*=2)>9&&(f-=9),e+=f,g=!g;return e%10===0},minlength:function(b,c,d){var e=a.isArray(b)?b.length:this.getLength(a.trim(b),c);return this.optional(c)||e>=d},maxlength:function(b,c,d){var e=a.isArray(b)?b.length:this.getLength(a.trim(b),c);return this.optional(c)||d>=e},rangelength:function(b,c,d){var e=a.isArray(b)?b.length:this.getLength(a.trim(b),c);return this.optional(c)||e>=d[0]&&e<=d[1]},min:function(a,b,c){return this.optional(b)||a>=c},max:function(a,b,c){return this.optional(b)||c>=a},range:function(a,b,c){return this.optional(b)||a>=c[0]&&a<=c[1]},equalTo:function(b,c,d){var e=a(d);return this.settings.onfocusout&&e.unbind(".validate-equalTo").bind("blur.validate-equalTo",function(){a(c).valid()}),b===e.val()},remote:function(b,c,d){if(this.optional(c))return"dependency-mismatch";var e,f,g=this.previousValue(c);return this.settings.messages[c.name]||(this.settings.messages[c.name]={}),g.originalMessage=this.settings.messages[c.name].remote,this.settings.messages[c.name].remote=g.message,d="string"==typeof d&&{url:d}||d,g.old===b?g.valid:(g.old=b,e=this,this.startRequest(c),f={},f[c.name]=b,a.ajax(a.extend(!0,{url:d,mode:"abort",port:"validate"+c.name,dataType:"json",data:f,context:e.currentForm,success:function(d){var f,h,i,j=d===!0||"true"===d;e.settings.messages[c.name].remote=g.originalMessage,j?(i=e.formSubmitted,e.prepareElement(c),e.formSubmitted=i,e.successList.push(c),delete e.invalid[c.name],e.showErrors()):(f={},h=d||e.defaultMessage(c,"remote"),f[c.name]=g.message=a.isFunction(h)?h(b):h,e.invalid[c.name]=!0,e.showErrors(f)),g.valid=j,e.stopRequest(c,j)}},d)),"pending")}}}),a.format=function(){throw"$.format has been deprecated. Please use $.validator.format instead."};var b,c={};a.ajaxPrefilter?a.ajaxPrefilter(function(a,b,d){var e=a.port;"abort"===a.mode&&(c[e]&&c[e].abort(),c[e]=d)}):(b=a.ajax,a.ajax=function(d){var e=("mode"in d?d:a.ajaxSettings).mode,f=("port"in d?d:a.ajaxSettings).port;return"abort"===e?(c[f]&&c[f].abort(),c[f]=b.apply(this,arguments),c[f]):b.apply(this,arguments)}),a.extend(a.fn,{validateDelegate:function(b,c,d){return this.bind(c,function(c){var e=a(c.target);return e.is(b)?d.apply(e,arguments):void 0})}})});

jQuery.extend(jQuery.validator.messages, {
  required: "Este campo es obligatorio.",
  remote: "Por favor, rellena este campo.",
  email: "Por favor, escribe una dirección de correo válida",
  url: "Por favor, escribe una URL válida.",
  date: "Por favor, escribe una fecha válida.",
  dateISO: "Por favor, escribe una fecha (ISO) válida.",
  number: "Por favor, escribe un número entero válido.",
  digits: "Por favor, escribe sólo dígitos.",
  creditcard: "Por favor, escribe un número de tarjeta válido.",
  equalTo: "Por favor, escribe el mismo valor de nuevo.",
  accept: "Por favor, escribe un valor con una extensión aceptada.",
  maxlength: jQuery.validator.format("Por favor, no escribas más de {0} caracteres."),
  minlength: jQuery.validator.format("Por favor, no escribas menos de {0} caracteres."),
  rangelength: jQuery.validator.format("Por favor, escribe un valor entre {0} y {1} caracteres."),
  range: jQuery.validator.format("Por favor, escribe un valor entre {0} y {1}."),
  max: jQuery.validator.format("Por favor, escribe un valor menor o igual a {0}."),
  min: jQuery.validator.format("Por favor, escribe un valor mayor o igual a {0}.")
});</script>

<script type="text/javascript">
/*  $.validator.setDefaults({
    submitHandler: function() {
      alert("submitted!");
    }
  });*/
$(document).on('ready',function(){

  $("#persona_natural").validate({
      rules: {
          "nro_expediente_congreso": {
            required: true,
            minlength: {
                param:6,
                depends: function (element) {
                    return $("#exp_congreso").is(":checked");
                }
            }
          },
          "nro_expediente_minedu": {
            required: true,
            minlength: {
                param:6,
                depends: function (element) {
                    return $("#exp_minedu").is(":checked");
                }
            }
          },
          "nro_expediente_pj": {
            required: true,
            minlength: {
                param:6,
                depends: function (element) {
                    return $("#exp_pj").is(":checked");
                }
            }
          },
          "nro_expediente_contraloria": {
            required: true,
            minlength: {
                param:6,
                depends: function (element) {
                    return $("#exp_contraloria").is(":checked");
                }
            }
          },
          "nro_expediente_indecopi": {
            required: true,
            minlength: {
                param:6,
                depends: function (element) {
                    return $("#exp_indecopi").is(":checked");
                }
            }
          },
          "nro_expediente_otro": {
            required: true,
            minlength: {
                param:6,
                depends: function (element) {
                    return $("#exp_otro").is(":checked");
                }
            }
          },
          "campo_otro": {
            required: true,
            minlength: {
                param:6,
                depends: function (element) {
                    return $("#exp_otro").is(":checked");
                }
            }
          },                                        
      },
  });

  var selectorDNI = $('input.dni');
  Inputmask("9", { repeat: 8 }).mask(selectorDNI);

  var selectorTelefono = $('input.telefono');
  Inputmask("(999) 9{5,9}").mask(selectorTelefono);

  function activarOtraInstancia(event){
    var valor = $('.otra_instancia').val();
    if(valor == 'Si'){
      $('.checkboxesOtraInstancia input[type="checkbox"]').attr('disabled',false);
    }else{
      $('.checkboxesOtraInstancia input[type="checkbox"]').attr('disabled',true);
    }
  }

  $('.otra_instancia').on('change',activarOtraInstancia);

  function activarNumExpediente(clase){
    var activo = $('input.'+clase+'[type="checkbox"]').is(':checked');
    if(activo){
      $('input.'+clase+'[type="text"]').attr('disabled',false); 
    }else{
      $('input.'+clase+'[type="text"]').attr('disabled',true); 
    }
  }

    $('input.exp_congreso[type="checkbox"]').on('click',function(){
      activarNumExpediente('exp_congreso');
    });
    $('input.exp_minedu[type="checkbox"]').on('click',function(){
      activarNumExpediente('exp_minedu');
    });
    $('input.exp_pj[type="checkbox"]').on('click',function(){
      activarNumExpediente('exp_pj');
    });
    $('input.exp_contraloria[type="checkbox"]').on('click',function(){
      activarNumExpediente('exp_contraloria');
    });
    $('input.exp_indecopi[type="checkbox"]').on('click',function(){
      activarNumExpediente('exp_indecopi');
    }); 
    $('input.exp_otro[type="checkbox"]').on('click',function(){
      activarNumExpediente('exp_otro');
    });

    getDataSelect("http://localhost/suneduFiscalizacion/public/universidades",".nombre_institucion");

    function getDataSelect(url,classControl){
        var request = $.ajax({
          url: url,
          method: "GET",
          dataType: "json"
        });
         
        request.done(function( data ) {
          data.forEach(function(obj,i){
            var option = $("<option>");
            option.val(obj.id);
            option.append(obj.nombre);
            $(classControl).append(option);
          });
        });
         
        request.fail(function( jqXHR, textStatus ) {
          alert( "Request failed: " + textStatus );
        });      
    }                    
});  
</script>
</body>
</html>
